{"file_contents":{"LICENSE.md":{"content":"MIT License\n\nCopyright (c) 2023 iTz Arshia\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n","size_bytes":1067},"README.md":{"content":"<h1 align=\"center\">An Advanced Discord Music Bot for YOU</h1>\n\n<div align=\"center\">\n    <a href=\"https://github.com/iTzArshia/Discord-Music-Bot/stargazers\"> <img src=\"https://img.shields.io/github/stars/iTzArshia/Discord-Music-Bot.svg\" alt=\"GitHub stars\"/> </a>\n    <a href=\"https://github.com/iTzArshia/Discord-Music-Bot/network\"> <img src=\"https://img.shields.io/github/forks/iTzArshia/Discord-Music-Bot.svg\" alt=\"GitHub forks\"/> </a>\n    <a href=\"https://discord.gg/nKrBshQvcK\"> <img src=\"https://badgen.net/discord/members/nKrBshQvcK\" alt=\"iTz Development Discord\"/> </a>\n    <a href=\"https://discord.gg/8hr9CRqmfc\"> <img src=\"https://badgen.net/discord/members/8hr9CRqmfc\" alt=\"iTz Club Discord\"/> </a>\n</div>\n\n# üìù Introduction\nWelcome to my Advanced Discord Music Bot! This open-source project is designed to enhance your Discord experience by providing seamless music playback from a wide array of platforms. Built with JavaScript, utilizing [Node.js v18.17.0](https://nodejs.org/en), [Discord.js v14](discord.js.org/), and [DisTube v5](https://distube.js.org/), this bot allows you to play songs from popular services such as YouTube, SoundCloud, Spotify, Deezer, Apple Music, and even Discord links, along with support for over 700 additional websites.\n\nWith a rich set of features and commands, this bot is not only powerful but also user-friendly. Whether you're hosting a party or just hanging out with friends, our bot ensures that your favorite tunes are just a command away. Explore the various functionalities and see the bot in action through the provided **[Screenshots](https://github.com/iTzArshia/Discord-Music-Bot#-screenshots)**!\n\nJoin us in creating a vibrant music community on Discord!\n\n## üî• Features\n- No API Key Required: Simple setup with no need for API keys.\n- Multi-Platform Support: Stream music from YouTube, SoundCloud, Spotify, Apple Music, Deezer, and over 700 additional websites.\n- Playlist Support: Play entire playlists from supported URLs.\n- Discord URL Playback: Play music directly from Discord links.\n- User-Friendly: Designed for ease of use, making it accessible for everyone.\n- AutoPlay: Automatically continues playing songs based on your listening preferences.\n- Audio Filters: Apply various filters to enhance your listening experience.\n- Song Navigation: Easily skip forward or backward through tracks.\n- Queue Management: Create and manage a queue of songs for uninterrupted playback.\n- Shuffle Mode: Enjoy a randomized playback experience with the shuffle feature.\n- And many many more features waiting for you...\n\n## üöß Requirements\n1. Discord Bot Token **[Guide](https://discordjs.guide/preparations/setting-up-a-bot-application.html#creating-your-bot)**  \n   1.1. Enable \"Message Content Intent\" in Discord Developer Portal\n2. **[Node.js v18.17.0](https://nodejs.org/en/download/)** or higher\n> NOTE: You don't need any API Key to set up the bot! the only thing you need is Node.js and a Discord bot Token to run your bot!\n\n# üöÄ Getting Started\nGo to `config.json` and fill out the values:\n```json\n{\n    \"Prefix\": \"Put anything you want as a prefix\",\n    \"MainColor\": \"Put any #HexCode you want for embeds color\",\n    \"ErrorColor\": \"Put any #HexCode you want for embeds color when there is an error\",\n    \"ClientID\": \"Put your Bot ID/Client ID here\",\n    \"Token\": \"Put your Bot Token here\"\n}\n```\n‚ö†Ô∏è **Note: Never commit or share your token publicly** ‚ö†Ô∏è\n\n## üß† installation\nOpen your terminal and install the required packages with\n```sh\nnpm install\n```\nAfter installation finishes run `node register.js` to deploy slash commands and then run `node index.js` in the terminal to start the bot.\n\n# üì∏ Screenshots\n![Help](https://github.com/user-attachments/assets/7e6eb7e6-ee15-465d-a3f5-30ec58bc7443)\n![Now Playing](https://github.com/user-attachments/assets/70c16d33-80f6-4960-98d8-e19350b303a3)\n![Search](https://github.com/user-attachments/assets/4cf184c1-4bfc-4e85-bf35-066ce575e838)\n![Queue](https://github.com/user-attachments/assets/f983d781-3c06-45e9-bfb0-17d926979443)\n\n# ‚ù§Ô∏è Support\nYou can **[support](https://reymit.com/itz_arshia)** me by donating if you like the project!\n> You can make international, crypto, or Tomanian donations through Reymit\n\n##\nMade with ‚ù§Ô∏è and JavaScript, Don't Forget to ‚≠ê\n","size_bytes":4299},"distube.js":{"content":"const { client } = require(\"./index\");\nconst { DisTube } = require(\"distube\");\nconst { YouTubePlugin } = require(\"@distube/youtube\");\nconst { SoundCloudPlugin } = require(\"@distube/soundcloud\");\nconst { SpotifyPlugin } = require(\"@distube/spotify\");\nconst { DeezerPlugin } = require(\"@distube/deezer\");\nconst { YtDlpPlugin } = require(\"@distube/yt-dlp\");\nconst { AppleMusicPlugin } = require(\"distube-apple-music\");\n\nclient.distubeSettings = {\n    leaveOnEmpty: true, // Whether or not leaving voice channel if the voice channel is empty after DisTubeOptions.emptyCooldown seconds.\n    leaveOnFinish: false, // Whether or not leaving voice channel when the queue ends.\n    leaveOnStop: true, // Whether or not leaving voice channel after using DisTube#stop function.\n    searchSongs: 10, // DONT SET IT MORE THAN 25!!! | Limit of search results emits in DisTube#event:searchResult event when DisTube#play method executed. If searchSongs <= 1, play the first result.\n    emptyCooldown: 60, // Built-in leave on empty cooldown in seconds. (When leaveOnEmpty is true)\n    directLink: true, // Whether or not play direct link of the song.\n    deleteAfterFinish: false, // Deletes Now Playing Message after song finished.\n};\n\nconst distubePlugins = [\n    new YouTubePlugin(), // YouTube plugin.\n    new SoundCloudPlugin(), // SoundCloud plugin.\n    new SpotifyPlugin(), // Spotify plugin.\n    new DeezerPlugin(), // Deezer plugin.\n    new AppleMusicPlugin(), // Apple Music plugin.\n];\n\nif (client.distubeSettings.directLink) {\n    const { DirectLinkPlugin } = require(\"@distube/direct-link\");\n    distubePlugins.push(new DirectLinkPlugin());\n}\n\n// YtDlpPlugin must be added last\ndistubePlugins.push(new YtDlpPlugin());\n\n// Set FFmpeg path in environment for maximum compatibility\nconst ffmpegPath = require('./utils/ffmpeg-resolver').findFfmpeg();\nprocess.env.FFMPEG_PATH = ffmpegPath;\nconsole.log(`üéµ FFmpeg configurado para DisTube: ${ffmpegPath}`);\n\n// DisTube client constructor\nclient.distube = new DisTube(client, {\n    // Change these on your risk! more info https://distube.js.org/#/docs/DisTube/stable/typedef/DisTubeOptions\n    emitNewSongOnly: false, // Whether or not emitting DisTube#event:playSong event when looping a song or next song is the same as the previous one.\n    savePreviousSongs: true, // Whether or not saving the previous songs of the queue and enable DisTube#previous method.\n    nsfw: false, // Whether or not playing age-restricted content and disabling safe search in non-NSFW channel.\n    emitAddListWhenCreatingQueue: true, // Whether or not emitting addList event when creating a new Queue.\n    emitAddSongWhenCreatingQueue: true, // Whether or not emitting addSong event when creating a new Queue.\n    joinNewVoiceChannel: false, // Whether or not joining the new voice channel when using DisTube#play method.\n    plugins: distubePlugins\n});\n\n// Voice connection optimization for Replit environment\nconsole.log('üéµ Configurando optimizaciones de voz para Replit...');\n\n// ========================= CRITICAL: VOICE ENCODER VERIFICATION =========================\nconsole.log('üîç Verificando codificador de voz...');\n\n// Runtime voice encoder detection and verification\nfunction verifyVoiceEncoder() {\n    let detectedEncoder = 'unknown';\n    let encoderWorking = false;\n    \n    try {\n        // Try to detect opusscript (version 0.0.8 API)\n        const OpusScript = require('opusscript');\n        if (OpusScript && typeof OpusScript === 'function' && OpusScript.Application) {\n            // Test creating an encoder to verify it works\n            const testEncoder = new OpusScript(48000, 2, OpusScript.Application.AUDIO);\n            if (testEncoder) {\n                detectedEncoder = 'opusscript';\n                encoderWorking = true;\n                console.log('‚úÖ opusscript detectado y funcional (v0.0.8 API)');\n            }\n        }\n    } catch (error) {\n        console.log('‚ùå opusscript no encontrado o no funcional:', error.message);\n    }\n    \n    try {\n        // Check if @discordjs/opus was accidentally installed\n        require('@discordjs/opus');\n        console.log('‚ö†Ô∏è  ADVERTENCIA: @discordjs/opus detectado - esto puede causar problemas en Replit');\n        console.log('üîß Ejecuta: npm uninstall @discordjs/opus');\n    } catch (error) {\n        console.log('‚úÖ @discordjs/opus no encontrado (correcto para Replit)');\n    }\n    \n    // Fail fast if no working encoder detected\n    if (!encoderWorking) {\n        console.error('üö® ERROR CR√çTICO: No se detect√≥ un codificador de voz funcional');\n        console.error('üîß Instala opusscript: npm install opusscript');\n        process.exit(1);\n    }\n    \n    console.log(`üéµ Codificador de voz verificado: ${detectedEncoder}`);\n    return { encoder: detectedEncoder, working: encoderWorking };\n}\n\n// Run encoder verification\nconst encoderStatus = verifyVoiceEncoder();\n\n// ========================= VOICE CONNECTION DIAGNOSTICS =========================\nconsole.log('üîß Configurando diagn√≥sticos de conexi√≥n de voz...');\n\n// Voice connection state monitoring\nfunction setupVoiceConnectionDiagnostics(distube) {\n    // Note: DisTube voices manager doesn't have 'on' method for general debug events\n    // The diagnostics are implemented in the join method wrapper below\n    \n    // Track connection attempts and timeouts\n    const connectionAttempts = new Map();\n    \n    // Wrap the join method to add diagnostics\n    const originalJoin = distube.voices.join.bind(distube.voices);\n    distube.voices.join = async function(voiceChannel, options = {}) {\n        const guildId = voiceChannel.guild.id;\n        const channelName = voiceChannel.name || 'Unknown';\n        \n        console.log(`üîó Intentando conectar a canal de voz: ${channelName} (Guild: ${guildId})`);\n        console.log(`üéµ Usando codificador: ${encoderStatus.encoder}`);\n        \n        const startTime = Date.now();\n        connectionAttempts.set(guildId, { startTime, channelName });\n        \n        try {\n            const connection = await originalJoin(voiceChannel, {\n                ...options,\n                debug: true // Enable debug logging\n            });\n            \n            const duration = Date.now() - startTime;\n            console.log(`‚úÖ Conectado exitosamente en ${duration}ms a ${channelName}`);\n            \n            // Monitor connection state changes\n            connection.on('stateChange', (oldState, newState) => {\n                console.log(`üîÑ Estado de conexi√≥n cambi√≥: ${oldState.status} ‚Üí ${newState.status} en ${channelName}`);\n                \n                if (newState.status === 'disconnected') {\n                    console.log(`‚ùå Desconectado de ${channelName}:`, newState.reason);\n                }\n                \n                if (newState.status === 'destroyed') {\n                    console.log(`üí• Conexi√≥n destruida en ${channelName}:`, newState.reason);\n                    connectionAttempts.delete(guildId);\n                }\n            });\n            \n            // Monitor for connection timeout\n            const timeoutWarning = setTimeout(() => {\n                if (connection.state.status !== 'ready') {\n                    console.log(`‚ö†Ô∏è  Conexi√≥n tomando m√°s tiempo del esperado en ${channelName}`);\n                }\n            }, 10000); // 10 seconds warning\n            \n            connection.once('stateChange', () => {\n                clearTimeout(timeoutWarning);\n            });\n            \n            connectionAttempts.delete(guildId);\n            return connection;\n            \n        } catch (error) {\n            const duration = Date.now() - startTime;\n            console.error(`‚ùå Error conectando a ${channelName} despu√©s de ${duration}ms:`, error.message);\n            connectionAttempts.delete(guildId);\n            throw error;\n        }\n    };\n    \n    // Periodic connection health check\n    setInterval(() => {\n        const now = Date.now();\n        for (const [guildId, attempt] of connectionAttempts.entries()) {\n            const duration = now - attempt.startTime;\n            if (duration > 30000) { // 30 seconds timeout\n                console.error(`üö® Timeout conectando a ${attempt.channelName} despu√©s de ${duration}ms`);\n                connectionAttempts.delete(guildId);\n            }\n        }\n    }, 5000); // Check every 5 seconds\n}\n\n// Apply diagnostics to distube after initialization\nsetTimeout(() => {\n    if (client.distube && client.distube.voices) {\n        setupVoiceConnectionDiagnostics(client.distube);\n        console.log('‚úÖ Diagn√≥sticos de voz configurados correctamente');\n    } else {\n        console.error('‚ùå No se pudieron configurar los diagn√≥sticos de voz');\n    }\n}, 1000);\n\nconsole.log('üéµ Usando opusscript como codificador de audio para mejor compatibilidad');\n","size_bytes":8849},"index.js":{"content":"/*\n    Author: iTz Arshia\n    Github: https://github.com/iTzArshia/Discord-Music-Bot\n    Current Version: 2.0.0\n    DiscordJs Version: 14.15.3\n    DisTube Version: 5.0.2\n    @discordjs/voice Version: 0.17.0\n*/\n\nconst Discord = require(\"discord.js\");\nconst fs = require(\"node:fs\");\nconst config = require(\"./config.json\");\n\n// Load environment variables for Discord credentials\nconst discordConfig = {\n    ...config,\n    Token: process.env.DISCORD_BOT_TOKEN || config.Token,\n    ClientID: process.env.DISCORD_CLIENT_ID || config.ClientID\n};\n\n// Discord Client Constructor\nconst client = new Discord.Client({\n    intents: [\n        Discord.GatewayIntentBits.Guilds,\n        Discord.GatewayIntentBits.GuildVoiceStates,\n        Discord.GatewayIntentBits.GuildMessages,\n        Discord.GatewayIntentBits.MessageContent,\n    ],\n});\n\nclient.MessageCommands = new Discord.Collection();\nclient.SlashCommands = new Discord.Collection();\nclient.CurrentSongs = [];\n\nmodule.exports.client = client;\nrequire(\"./distube\");\n\n// Event Handler\nconsole.log(`Loading Discord Events`);\nconst discordEvents = fs.readdirSync(`./events/discord/`).filter((file) => file.endsWith(\".js\"));\nfor (const file of discordEvents) {\n    const event = require(`./events/discord/${file}`);\n    client.on(file.split(\".\")[0], event.bind(null, client));\n}\n\n// DisTube Event Handler\nconsole.log(`Loading DisTube Events`);\nconst distubeEvents = fs.readdirSync(`./events/distube/`).filter((file) => file.endsWith(\".js\"));\nfor (const file of distubeEvents) {\n    const event = require(`./events/distube/${file}`);\n    client.distube.on(file.split(\".\")[0], event.bind(null, client));\n}\n\n// Message Command Handler\nconsole.log(`Loading Message Commands`);\nconst messageCommands = fs.readdirSync(`./commands/messages/`).filter((files) => files.endsWith(\".js\"));\nfor (const file of messageCommands) {\n    const command = require(`./commands/messages/${file}`);\n    client.MessageCommands.set(command.name.toLowerCase(), command);\n}\n\n// Slash Command Handler\nconsole.log(`Loading Slash Commands`);\nconst slashCommands = fs.readdirSync(`./commands/interactions/`).filter((files) => files.endsWith(\".js\"));\nfor (const file of slashCommands) {\n    const command = require(`./commands/interactions/${file}`);\n    client.SlashCommands.set(command.data.name, command);\n}\n\n// Anti Crash\nprocess.on(\"unhandledRejection\", (reason, p) => {\n    console.log(\"[antiCrash] :: Unhandled Rejection/Catch\");\n    console.log(reason?.stack, p);\n});\n\nprocess.on(\"uncaughtException\", (err, origin) => {\n    console.log(\"[antiCrash] :: Uncaught Exception/Catch\");\n    console.log(err?.stack, origin);\n});\n\nprocess.on(\"uncaughtExceptionMonitor\", (err, origin) => {\n    console.log(\"[antiCrash] :: Uncaught Exception/Catch (MONITOR)\");\n    console.log(err?.stack, origin);\n});\n\n// Discord Client login\nclient.login(discordConfig.Token);\n","size_bytes":2865},"register.js":{"content":"const Discord = require(\"discord.js\");\nconst fs = require(\"node:fs\");\nconst config = require(\"./config.json\");\n\n// Load environment variables for Discord credentials\nconst discordConfig = {\n    ...config,\n    Token: process.env.DISCORD_BOT_TOKEN || config.Token,\n    ClientID: process.env.DISCORD_CLIENT_ID || config.ClientID\n};\nconst commands = [];\n\nconst commandFiles = fs.readdirSync(`./commands/interactions`).filter((file) => file.endsWith(\".js\"));\n\nfor (const file of commandFiles) {\n    const command = require(`./commands/interactions/${file}`);\n    commands.push(command.data.toJSON());\n}\n\nconst rest = new Discord.REST({ version: \"10\" }).setToken(discordConfig.Token);\n\n(async () => {\n    try {\n        console.log(`Started refreshing ${commands.length} application (/) commands.`);\n\n        const data = await rest.put(Discord.Routes.applicationCommands(discordConfig.ClientID), { body: commands });\n\n        console.log(`Successfully reloaded ${data.length} application (/) commands.`);\n    } catch (error) {\n        console.error(error);\n    }\n})();\n","size_bytes":1063},"replit.md":{"content":"# Discord Music Bot\n\n**Overview:** An Advanced Discord Music Bot that supports multiple music platforms including YouTube, SoundCloud, Spotify, Apple Music, Deezer, and over 700 additional websites through yt-dlp integration.\n\n**Current State:** Successfully imported and configured for the Replit environment. The bot is running and operational with all known issues resolved.\n\n## Recent Changes (September 12, 2025)\n- Imported from GitHub repository (iTzArshia/Discord-Music-Bot v2.2.1)\n- Configured environment variable support for Discord credentials\n- Set up proper workflow for console-based Discord bot\n- Registered 24 slash commands successfully\n- Bot is online and ready for music playback\n- **FIXED:** Updated ready event to clientReady for Discord.js v14+ compatibility\n- **FIXED:** Moved YtDlpPlugin to last position in plugin array\n- **IMPROVED:** Dynamic ffmpeg path resolution for better Replit compatibility\n- **COMPLETED:** Full Spanish translation of message commands (!commands)\n- **FIXED:** Help command category mismatch with Spanish translations\n- **RESOLVED:** Alias conflicts and improved Spanish command aliases\n- **IMPLEMENTED:** Portable FFmpeg solution for cross-platform compatibility\n- **SECURED:** Server restriction system - bot only works in authorized servers\n- **ENHANCED:** Multi-platform FFmpeg detection with environment variable configuration\n\n## Project Architecture\n- **Language:** Node.js 20 with Discord.js v14 and DisTube v5\n- **Main Files:** \n  - `index.js` - Main bot entry point\n  - `register.js` - Slash command registration\n  - `distube.js` - Music system configuration with optimized plugin order\n  - `config.json` - Configuration settings\n- **Commands:** Located in `commands/` directory with both slash commands and message commands\n- **Events:** Discord and DisTube event handlers in `events/` directory\n\n## Key Features\n- Multi-platform music streaming (YouTube, Spotify, SoundCloud, etc.)\n- Slash command and message command support\n- Queue management, shuffle, loop, and audio filters\n- AutoPlay functionality\n- Voice channel management\n- Robust audio encoding with fallback options\n\n## Environment Setup\n- Uses `DISCORD_BOT_TOKEN` and `DISCORD_CLIENT_ID` from Replit Secrets\n- Falls back to config.json values if environment variables not set\n- Dependencies installed with workaround for native modules using opusscript\n- Dynamic ffmpeg path resolution (ffmpeg-static ‚Üí system ffmpeg)\n- Build tools installed (gcc, make, pkg-config) for potential native compilation\n\n## Production Notes\n- Uses opusscript instead of @discordjs/opus for better Replit compatibility\n- YtDlpPlugin positioned last for optimal functionality\n- Console-based workflow configured for Discord bot operation\n- All deprecation warnings resolved for Discord.js v14+\n\n## Security & Access Control\n- **Server Restrictions**: Bot only operates in authorized servers (IDs: 1405727340335468665, 1393290240214438021)\n- **Auto-leave System**: Automatically exits unauthorized servers with notification\n- **Command Validation**: All commands and interactions blocked in unauthorized servers\n\n## Cross-Platform Compatibility\n- **Portable FFmpeg Solution**: Robust multi-strategy FFmpeg detection for any hosting platform\n- **Environment Variable Configuration**: Sets FFMPEG_PATH for maximum compatibility\n- **Multiple Detection Methods**: System paths, ffmpeg-static, common locations, and PATH scanning\n\n## Running the Bot\nThe bot runs automatically via the \"Discord Music Bot\" workflow. Bot status shows \"Elite Music#7829 est√° en l√≠nea y listo para reproducir m√∫sica para ti!\" when connected successfully.","size_bytes":3633},"utils/components.js":{"content":"const Discord = require(\"discord.js\");\n\nconst paginationStartButton = new Discord.ButtonBuilder().setCustomId(\"page-start\").setLabel(\"First\").setStyle(Discord.ButtonStyle.Secondary);\n\nconst paginationBackButton = new Discord.ButtonBuilder().setCustomId(\"page-back\").setLabel(\"Previous\").setStyle(Discord.ButtonStyle.Secondary);\n\nconst paginationForwardButton = new Discord.ButtonBuilder().setCustomId(\"page-forward\").setLabel(\"Next\").setStyle(Discord.ButtonStyle.Secondary);\n\nconst paginationEndButton = new Discord.ButtonBuilder().setCustomId(\"page-end\").setLabel(\"Last\").setStyle(Discord.ButtonStyle.Secondary);\n\nmodule.exports.paginationStartButton = paginationStartButton;\nmodule.exports.paginationBackButton = paginationBackButton;\nmodule.exports.paginationForwardButton = paginationForwardButton;\nmodule.exports.paginationEndButton = paginationEndButton;\n","size_bytes":861},"utils/functions.js":{"content":"module.exports = {\n    suffix: function (number) {\n        // 1 => 1st, 2 => 2nd, 3 => 3rd, 4 => 4th...\n        let j = number % 10,\n            k = number % 100;\n        if (j === 1 && k !== 11) return number + \"st\";\n        if (j === 2 && k !== 12) return number + \"nd\";\n        if (j === 3 && k !== 13) return number + \"rd\";\n        return number + \"th\";\n    },\n\n    numberWithCommas: function (number) {\n        // 1000 to 1,000\n        return number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n    },\n\n    timestamp: function (ms) {\n        return `<t:${Math.trunc(ms / 1000)}:D> | <t:${Math.trunc(ms / 1000)}:R>`;\n    },\n\n    queueStatus: function (queue) {\n        // Queue status template\n        return `**Volume:** \\`${queue.volume}%\\` | **Filters:** \\`${queue.filters.names.join(\", \") || \"OFF\"}\\` | **Loop:** \\`${\n            queue.repeatMode ? (queue.repeatMode === 2 ? \"All Queue\" : \"This Song\") : \"OFF\"\n        }\\` | **Autoplay:** \\`${queue.autoplay ? \"ON\" : \"OFF\"}\\``;\n    },\n};\n","size_bytes":1000},"commands/interactions/autoplay.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"autoplay\").setDescription(\"Toggles auto play.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            const autoPlayState = await queue.toggleAutoplay();\n\n            const autoplayEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîß Auto Play\")\n                .setDescription(`Auto Play mode changed to \\`${autoPlayState ? \"ON\" : \"OFF\"}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.editReply({ embeds: [autoplayEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1703},"commands/interactions/backward.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"backward\")\n        .setDescription(\"Backwards the playing song.\")\n        .addIntegerOption((option) => option.setName(\"time\").setDescription(\"Provide time in seconds.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const time = interaction.options.getInteger(\"time\");\n\n        try {\n            await queue.seek(queue.currentTime - time);\n\n            const seekEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è™ Backward\")\n                .setDescription(`Backwarded the song for ${time} seconds.`)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [seekEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1803},"commands/interactions/connect.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"connect\").setDescription(\"Se conecta a tu canal de voz actual.\"),\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        if (memberVC && botVC && memberVC.id === botVC.id) {\n            const inVoiceEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Ya estoy conectado a tu canal de voz.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            return interaction.editReply({ embeds: [inVoiceEmbed] });\n        }\n\n        try {\n            await client.distube.voices.join(memberVC);\n\n            const joinEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üëãüèª Conectado\")\n                .setDescription(\"Me he conectado a tu canal de voz.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [joinEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al conectar: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2254},"commands/interactions/disconnect.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"disconnect\").setDescription(\"Se desconecta de tu canal de voz actual.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            await client.distube.voices.leave(interaction.guild);\n\n            const leaveEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üëãüèª Desconectado\")\n                .setDescription(\"Me he desconectado de tu canal de voz.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [leaveEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al desconectar: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1680},"commands/interactions/filters.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"filter\")\n        .setDescription(\"Applies different audio filters.\")\n        .addStringOption((option) =>\n            option\n                .setName(\"filter\")\n                .setDescription(\"Select any filter you want to ON/OFF.\")\n                .setChoices(\n                    { name: \"OFF\", value: \"off\" },\n                    { name: \"3D\", value: \"3d\" },\n                    { name: \"BassBoost\", value: \"bassboost\" },\n                    { name: \"Earwax\", value: \"earwax\" },\n                    { name: \"Echo\", value: \"echo\" },\n                    { name: \"Flanger\", value: \"flanger\" },\n                    { name: \"Gate\", value: \"gate\" },\n                    { name: \"Haas\", value: \"haas\" },\n                    { name: \"Karaoke\", value: \"karaoke\" },\n                    { name: \"Mcompand\", value: \"mcompand\" },\n                    { name: \"NightCore\", value: \"nightcore\" },\n                    { name: \"Phaser\", value: \"phaser\" },\n                    { name: \"Reverse\", value: \"reverse\" },\n                    { name: \"Surround\", value: \"surround\" },\n                    { name: \"Tremolo\", value: \"tremolo\" },\n                    { name: \"VaporWave\", value: \"vaporwave\" }\n                )\n                .setRequired(true)\n        ),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const filter = interaction.options.getString(\"filter\").toLowerCase();\n\n        try {\n            if (filter === \"off\" && queue.filters.size) {\n                await queue.filters.clear();\n            } else if (Object.keys(client.distube.filters).includes(filter)) {\n                if (queue.filters.has(filter)) {\n                    await queue.filters.remove(filter);\n                } else {\n                    await queue.filters.add(filter);\n                }\n            }\n\n            const filtersEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üéß Filter\")\n                .setDescription(`**Current Queue Filters:** \\`${queue.filters.names.join(\", \") || \"OFF\"}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [filtersEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":3331},"commands/interactions/forward.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"forward\")\n        .setDescription(\"Forwards the playing song.\")\n        .addIntegerOption((option) => option.setName(\"time\").setDescription(\"Time to go forward in seconds.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const time = Number(interaction.options.getInteger(\"time\"));\n\n        try {\n            await queue.seek(queue.currentTime + time);\n\n            const seekEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è© Forward\")\n                .setDescription(`forwarded the song for ${time} seconds.`)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [seekEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1813},"commands/interactions/help.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"help\")\n        .setDescription(\"Muestra la lista de comandos e informaci√≥n del bot.\")\n        .addStringOption((option) => option.setName(\"comando\").setDescription(\"Nombre del comando espec√≠fico para informaci√≥n detallada.\")),\n    memberVoice: false,\n    botVoice: false,\n    sameVoice: false,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const playCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Play Commands\");\n        const songCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Song Commands\");\n        const queueCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Queue Commands\");\n        const utilitiesCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Utilities Commands\");\n\n        const helpEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setTitle(\"‚ùì Ayuda\")\n            .setFooter({ text: \"Desarrollado por <@1404572152014962708> ‚Ä¢ Bot de M√∫sica Avanzado\" });\n\n        const comandoName = interaction.options.getString(\"comando\");\n        \n        if (\n            comandoName &&\n            (client.MessageCommands.find((command) => command.name.toLowerCase() === comandoName.toLowerCase()) ||\n                client.MessageCommands.find((c) => c.aliases?.map((aliase) => aliase.toLowerCase()).includes(comandoName.toLowerCase())))\n        ) {\n            const command =\n                client.MessageCommands.find((command) => command.name.toLowerCase() === comandoName.toLowerCase()) ||\n                client.MessageCommands.find((c) => c.aliases?.map((aliase) => aliase.toLowerCase()).includes(comandoName.toLowerCase()));\n\n            helpEmbed.setDescription(`Informaci√≥n detallada sobre **${command.name}**:`).addFields(\n                {\n                    name: \"Nombre del Comando:\",\n                    value: `\\`${config.Prefix}${command.name}\\``,\n                    inline: false,\n                },\n                {\n                    name: \"Sin√≥nimos:\",\n                    value: command.aliases\n                        ? command.aliases.map((aliase) => `\\`${config.Prefix}${aliase}\\``).join(\" | \")\n                        : \"No hay sin√≥nimos para este comando\",\n                    inline: false,\n                },\n                {\n                    name: \"Uso:\",\n                    value: command.usage ? config.Prefix + command.usage : \"`No hay uso espec√≠fico para este comando`\",\n                    inline: false,\n                },\n                {\n                    name: \"Descripci√≥n:\",\n                    value: command.description || \"`No hay descripci√≥n para este comando`\",\n                    inline: false,\n                }\n            );\n        } else {\n            helpEmbed\n                .setDescription(\n                    `Tambi√©n puedes usar el comando \\`${config.Prefix}Help CMD\\` para acceder a informaci√≥n detallada sobre los comandos disponibles y sus funcionalidades. Bot desarrollado por <@1404572152014962708>`\n                )\n                .addFields(\n                    {\n                        name: \"üéµ Comandos de Reproducci√≥n:\",\n                        value: playCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    },\n                    {\n                        name: \"üé∂ Comandos de Canci√≥n:\",\n                        value: songCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    },\n                    {\n                        name: \"üìã Comandos de Cola:\",\n                        value: queueCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    },\n                    {\n                        name: \"üîß Comandos de Utilidades:\",\n                        value: utilitiesCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    }\n                );\n        }\n\n        await interaction.editReply({ embeds: [helpEmbed] });\n    },\n};\n","size_bytes":4554},"commands/interactions/loop.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"loop\")\n        .setDescription(\"Changes loop mode.\")\n        .addStringOption((option) =>\n            option\n                .setName(\"mode\")\n                .setDescription(\"loop song or queue.\")\n                .setChoices({ name: \"OFF\", value: \"0\" }, { name: \"Song\", value: \"1\" }, { name: \"Queue\", value: \"2\" })\n                .setRequired(true)\n        ),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            const selectedMode = interaction.options.getString(\"mode\");\n            await queue.setRepeatMode(selectedMode);\n            const mode = selectedMode ? (selectedMode === 2 ? \"All Queue\" : \"This Song\") : \"OFF\";\n\n            const loopEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîÅ Loop\")\n                .setDescription(`Loop mode changed to \\`${mode}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [loopEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2145},"commands/interactions/nowplaying.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"nowplaying\").setDescription(\"Muestra la canci√≥n que se est√° reproduciendo actualmente.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const voiceChannelMembers = botVC.members.filter((member) => !member.user.bot);\n\n        const nowEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setTitle(\"üíø Reproduciendo Ahora\")\n            .setDescription(\n                `Reproduciendo **[${queue.songs[0].name} (${queue.songs[0].formattedDuration})](${queue.songs[0].url})** para ${\n                    voiceChannelMembers.size\n                } ${voiceChannelMembers.size > 1 ? \"oyentes\" : \"oyente\"} en ${botVC}\\n\\n${func.queueStatus(queue)}\\n\\nü§ñ Bot desarrollado por <@1404572152014962708>`\n            )\n            .setThumbnail(queue.songs[0]?.thumbnail)\n            .setFooter({\n                text: `Canci√≥n solicitada por ${queue.songs[0].user.globalName || queue.songs[0].user.username}`,\n                iconURL: queue.songs[0].user.displayAvatarURL({ size: 1024 }),\n            });\n\n        if (queue.songs[0].views)\n            nowEmbed.addFields({\n                name: \"üëÄ Visualizaciones:\",\n                value: `${func.numberWithCommas(queue.songs[0].views)}`,\n                inline: true,\n            });\n\n        if (queue.songs[0].likes)\n            nowEmbed.addFields({\n                name: \"üëçüèª Me Gusta:\",\n                value: `${func.numberWithCommas(queue.songs[0].likes)}`,\n                inline: true,\n            });\n\n        if (queue.songs[0].dislikes)\n            nowEmbed.addFields({\n                name: \"üëéüèª No Me Gusta:\",\n                value: `${func.numberWithCommas(queue.songs[0].dislikes)}`,\n                inline: true,\n            });\n\n        await interaction.editReply({ embeds: [nowEmbed] });\n    },\n};\n","size_bytes":2171},"commands/interactions/pause.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"pause\").setDescription(\"Pausa la canci√≥n actual.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        if (queue.paused) {\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"La cola ya est√° pausada.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            return interaction.editReply({ embeds: [pauseEmbed] });\n        }\n\n        try {\n            await queue.pause();\n\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è∏Ô∏è Pausado\")\n                .setDescription(\"He pausado la canci√≥n para ti.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [pauseEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al pausar: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2160},"commands/interactions/ping.js":{"content":"const Discord = require(\"discord.js\");\nconst os = require(\"node:os\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"ping\").setDescription(\"Muestra la latencia del bot.\"),\n    memberVoice: false,\n    botVoice: false,\n    sameVoice: false,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const embed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setTitle(\"üèì ¬°Pong!\")\n            .setDescription(\"Estado del bot desarrollado por <@1404572152014962708>\")\n            .addFields(\n                {\n                    name: `üì° Latencia:`,\n                    value: `${client.ws.ping}ms`,\n                    inline: true,\n                },\n                {\n                    name: `üíæ Memoria:`,\n                    value: `${func.numberWithCommas(Math.round(process.memoryUsage().rss / 1024 / 1024))}/${func.numberWithCommas(\n                        Math.round(os.totalmem() / 1024 / 1024)\n                    )}MB`,\n                    inline: true,\n                },\n                {\n                    name: `‚è≥ Tiempo Activo:`,\n                    value: func.timestamp(client.readyTimestamp),\n                    inline: false,\n                }\n            )\n            .setFooter({\n                text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n            });\n\n        await interaction.editReply({ embeds: [embed] });\n    },\n};\n","size_bytes":1712},"commands/interactions/play.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"play\")\n        .setDescription(\"Reproduce m√∫sica para ti.\")\n        .addStringOption((option) => option.setName(\"query\").setDescription(\"Ingresa el nombre de la canci√≥n o lista de reproducci√≥n.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply({ ephemeral: true });\n\n        const query = interaction.options.getString(\"query\");\n\n        const searchEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setDescription(\"üîç Buscando m√∫sica...\")\n            .setFooter({\n                text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n            });\n\n        await interaction.editReply({ embeds: [searchEmbed] });\n\n        try {\n            await client.distube.play(memberVC, query, {\n                member: interaction.member,\n                textChannel: interaction.channel,\n            });\n\n            await interaction.deleteReply();\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al reproducir la m√∫sica: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1980},"commands/interactions/playskip.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"playskip\")\n        .setDescription(\"Plays the song and skips current song.\")\n        .addStringOption((option) => option.setName(\"query\").setDescription(\"Enter song name or playlist list.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply({ ephemeral: true });\n\n        const query = interaction.options.getString(\"query\");\n\n        const searchEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setDescription(\"Searching...\")\n            .setFooter({\n                text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n            });\n\n        await interaction.editReply({ embeds: [searchEmbed] });\n\n        try {\n            // await client.distube.play(memberVC, query, {\n            //     member: interaction.member,\n            //     textChannel: interaction.channel,\n            //     skip: true,\n            // });\n\n            await client.distube.play(memberVC, query, {\n                member: interaction.member,\n                textChannel: interaction.channel,\n                position: 1,\n            });\n            await queue.skip();\n\n            await interaction.deleteReply();\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2176},"commands/interactions/playtop.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"playtop\")\n        .setDescription(\"Plays the song before other songs in the queue.\")\n        .addStringOption((option) => option.setName(\"query\").setDescription(\"Enter song name or playlist list.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply({ ephemeral: true });\n\n        const query = interaction.options.getString(\"query\");\n\n        const searchEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setDescription(\"Searching...\")\n            .setFooter({\n                text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n            });\n\n        await interaction.editReply({ embeds: [searchEmbed] });\n\n        try {\n            await client.distube.play(memberVC, query, {\n                member: interaction.member,\n                textChannel: interaction.channel,\n                position: 1,\n            });\n\n            await interaction.deleteReply();\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1941},"commands/interactions/previous.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"previous\").setDescription(\"Plays previous song.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            await queue.previous();\n\n            const skippedEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîô Previous\")\n                .setDescription(\"Skipping to the previous song.\")\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [skippedEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1570},"commands/interactions/queue.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"queue\").setDescription(\"Muestra la cola de reproducci√≥n actual del servidor.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const queueSongs = queue.songs.map(\n            (song, i) => `${i === 0 ? \"**Reproduciendo:**\" : `${i}.`} ${song.name} (${song.formattedDuration}) - ${song.user}`\n        );\n        const n = queue.songs.length / 20;\n        const embeds = [];\n\n        for (let i = 0; n > i; i++) {\n            const queueEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(`üìÉ Cola de ${interaction.guild.name} [${i + 1}/${Math.ceil(n)}]`)\n                .setDescription(queueSongs.slice(i * 20, (i + 1) * 20).join(\"\\n\"))\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            embeds.push(queueEmbed);\n        }\n\n        const { paginationStartButton, paginationBackButton, paginationForwardButton, paginationEndButton } = require(\"../../utils/components\");\n        const startButton = Discord.ButtonBuilder.from(paginationStartButton);\n        const backButton = Discord.ButtonBuilder.from(paginationBackButton);\n        const forwardButton = Discord.ButtonBuilder.from(paginationForwardButton);\n        const endButton = Discord.ButtonBuilder.from(paginationEndButton);\n\n        let group = new Discord.ActionRowBuilder().addComponents([\n            startButton.setDisabled(true),\n            backButton.setDisabled(true),\n            forwardButton.setDisabled(true),\n            endButton.setDisabled(true),\n        ]);\n        if (embeds.length > 1)\n            group = new Discord.ActionRowBuilder().addComponents([\n                startButton.setDisabled(true),\n                backButton.setDisabled(true),\n                forwardButton.setDisabled(false),\n                endButton.setDisabled(false),\n            ]);\n\n        const reply = await interaction.editReply({\n            embeds: [embeds[0]],\n            components: [group],\n        });\n\n        const collector = reply.createMessageComponentCollector({ time: 60000 });\n\n        let currentPage = 0;\n\n        collector.on(\"collect\", async (int) => {\n            if (int.member.id !== interaction.user.id)\n                return int.reply({\n                    content: `Este bot√≥n solo funciona para ${interaction.user.globalName || interaction.user.username}`,\n                    ephemeral: true,\n                });\n\n            if (int.customId === \"page-start\") {\n                currentPage = 0;\n                group = new Discord.ActionRowBuilder().addComponents([\n                    startButton.setDisabled(true),\n                    backButton.setDisabled(true),\n                    forwardButton.setDisabled(false),\n                    endButton.setDisabled(false),\n                ]);\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            } else if (int.customId === \"page-back\") {\n                --currentPage;\n                if (currentPage === 0) {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(true),\n                        backButton.setDisabled(true),\n                        forwardButton.setDisabled(false),\n                        endButton.setDisabled(false),\n                    ]);\n                } else {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(false),\n                        backButton.setDisabled(false),\n                        forwardButton.setDisabled(false),\n                        endButton.setDisabled(false),\n                    ]);\n                }\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            } else if (int.customId === \"page-forward\") {\n                currentPage++;\n                if (currentPage === embeds.length - 1) {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(false),\n                        backButton.setDisabled(false),\n                        forwardButton.setDisabled(true),\n                        endButton.setDisabled(true),\n                    ]);\n                } else {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(false),\n                        backButton.setDisabled(false),\n                        forwardButton.setDisabled(false),\n                        endButton.setDisabled(false),\n                    ]);\n                }\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            } else if (int.customId === \"page-end\") {\n                currentPage = embeds.length - 1;\n                group = new Discord.ActionRowBuilder().addComponents([\n                    startButton.setDisabled(false),\n                    backButton.setDisabled(false),\n                    forwardButton.setDisabled(true),\n                    endButton.setDisabled(true),\n                ]);\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            }\n        });\n\n        collector.on(\"end\", async (collected, reason) => {\n            if ([\"messageDelete\", \"messageDeleteBulk\"].includes(reason)) return;\n            await reply.edit({\n                components: [\n                    new Discord.ActionRowBuilder().addComponents(\n                        startButton.setDisabled(true),\n                        backButton.setDisabled(true),\n                        forwardButton.setDisabled(true),\n                        endButton.setDisabled(true)\n                    ),\n                ],\n            });\n        });\n    },\n};\n","size_bytes":6212},"commands/interactions/resume.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"resume\").setDescription(\"Reanuda la canci√≥n actual.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        if (!queue.paused) {\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"La cola no est√° pausada.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            return interaction.editReply({ embeds: [pauseEmbed] });\n        }\n\n        try {\n            await queue.resume();\n\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚ñ∂Ô∏è Reanudado\")\n                .setDescription(\"He reanudado la canci√≥n para ti.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [pauseEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al reanudar: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2171},"commands/interactions/search.js":{"content":"const Discord = require(\"discord.js\");\nconst { YouTubePlugin } = require(\"@distube/youtube\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"search\")\n        .setDescription(\"Search song for you.\")\n        .addStringOption((option) => option.setName(\"query\").setDescription(\"Enter song name.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply({ ephemeral: true });\n\n        const query = interaction.options.getString(\"query\");\n\n        try {\n            const ytPlugin = new YouTubePlugin();\n            const songsArray = await ytPlugin.search(query, { type: \"video\", limit: client.distubeSettings.searchSongs, safeSearch: true });\n\n            const searchEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîç Search\")\n                .setDescription(\n                    `Please select one of the songs below to enjoy your chosen song!\\n\\n` +\n                        songsArray.map((song, index) => `[${index + 1}.](${song.url}) ${song.name} (${song.formattedDuration})`).join(\"\\n\")\n                )\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(\"songsMenu\")\n                .setPlaceholder(\"Select a song.\")\n                .setMaxValues(songsArray.length)\n                .addOptions(\n                    songsArray.map((song) => {\n                        return {\n                            label: song.name.length > 80 ? song.name.slice(0, 77) + \"...\" : song.name,\n                            value: song.id,\n                        };\n                    })\n                );\n\n            const row = new Discord.ActionRowBuilder().addComponents(menu);\n\n            const reply = await interaction.editReply({ embeds: [searchEmbed], components: [row] });\n            const collector = reply.createMessageComponentCollector({ time: 60000 });\n\n            collector.on(\"collect\", async (int) => {\n                if (int.member.id !== interaction.user.id)\n                    await int.reply({\n                        content: `‚ö†Ô∏è You can't use this, it's only works for ${interaction.user.globalName || interaction.user.username}`,\n                        ephemeral: true,\n                    });\n\n                await collector.stop(\"played\");\n                await int.deferUpdate();\n\n                for (const value of int.values) {\n                    const thisSong = songsArray.find((song) => song.id === value);\n\n                    await client.distube.play(memberVC, thisSong.url, {\n                        member: interaction.member,\n                        textChannel: interaction.channel,\n                    });\n                }\n            });\n\n            collector.on(\"end\", async (collected, reason) => {\n                if ([\"messageDelete\", \"messageDeleteBulk\"].includes(reason)) return;\n                menu.setDisabled();\n                const disabledRow = new Discord.ActionRowBuilder().addComponents(menu);\n                await reply.edit({ components: [disabledRow] });\n            });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":4112},"commands/interactions/seek.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\nconst func = require(\"../../utils/functions\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"seek\")\n        .setDescription(\"Seeks the playing song.\")\n        .addIntegerOption((option) => option.setName(\"time\").setDescription(\"Time in seconds.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const time = interaction.options.getInteger(\"time\");\n\n        try {\n            await queue.seek(time);\n\n            const seekEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è≥ Seek\")\n                .setDescription(`Seeked to ${func.suffix(time)} second of the song.`)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [seekEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1820},"commands/interactions/shuffle.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"shuffle\").setDescription(\"Mezcla aleatoriamente las canciones de la cola.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            await queue.shuffle();\n\n            const shuffleEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîÄ Mezclado\")\n                .setDescription(\"He mezclado las canciones de la cola aleatoriamente\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [shuffleEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al mezclar: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1657},"commands/interactions/skip.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"skip\").setDescription(\"Salta a la siguiente canci√≥n.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            await queue.skip();\n\n            const skippedEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è≠Ô∏è Saltado\")\n                .setDescription(\"Saltando a la siguiente canci√≥n.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [skippedEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al saltar: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1616},"commands/interactions/skipto.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"skipto\")\n        .setDescription(\"Skips to the provided song id in the queue.\")\n        .addStringOption((option) => option.setName(\"song-id\").setDescription(\"Enter the song id you want skip to.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const songId = interaction.options.getInteger(\"song-id\");\n\n        try {\n            await client.distube.jump(interaction.guild, songId).then(async (song) => {\n                const skippedEmbed = new Discord.EmbedBuilder()\n                    .setColor(config.MainColor)\n                    .setTitle(\"‚è≠Ô∏è Skip To\")\n                    .setDescription(`Skipped to the **${songId}. [${song.name} (${song.formattedDuration})](${song.url})**`)\n                    .setFooter({\n                        text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                        iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                    });\n\n                await interaction.editReply({ embeds: [skippedEmbed] });\n            });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1971},"commands/interactions/stop.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder().setName(\"stop\").setDescription(\"Detiene la cola de reproducci√≥n.\"),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        try {\n            await queue.stop();\n            if (client.distubeSettings.leaveOnStop) await queue.voice.leave();\n\n            const stopEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üö´ Detenido\")\n                .setDescription(\"He detenido la reproducci√≥n.\")\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [stopEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error al detener: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1688},"commands/interactions/volume.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    data: new Discord.SlashCommandBuilder()\n        .setName(\"volume\")\n        .setDescription(\"Establece el volumen del reproductor.\")\n        .addIntegerOption((option) => option.setName(\"volume\").setDescription(\"Ingresa el nuevo valor de volumen.\").setRequired(true)),\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, interaction, memberVC, botVC, queue) {\n        await interaction.deferReply();\n\n        const volume = interaction.options.getInteger(\"volume\");\n\n        try {\n            if (volume > 200 || volume < 0) {\n                const volumeEmbed = new Discord.EmbedBuilder().setColor(config.ErrorColor).setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n                if (volume > 200) volumeEmbed.setDescription(\"No puedes establecer el volumen mayor a `200`\");\n                if (volume < 0) volumeEmbed.setDescription(\"No puedes establecer el volumen menor a `0`\");\n\n                return interaction.editReply({ embeds: [volumeEmbed] });\n            }\n\n            await queue.setVolume(volume);\n\n            const volumeEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîä Volumen\")\n                .setDescription(`Volumen cambiado a \\`${volume}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [volumeEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(`Ocurri√≥ un error con el volumen: ${error.message.length > 4000 ? error.message.slice(0, 3997) + \"...\" : error.message}`)\n                .setFooter({\n                    text: `Solicitado por ${interaction.user.globalName || interaction.user.username} `,\n                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                });\n\n            await interaction.editReply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2594},"commands/messages/autoplay.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"AutoPlay\",\n    aliases: [\"A\", \"AP\", \"Auto\", \"automatico\"],\n    description: \"Alterna el modo de reproducci√≥n autom√°tica.\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        try {\n            const autoPlayState = await queue.toggleAutoplay();\n\n            const autoplayEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîß Reproducci√≥n Autom√°tica\")\n                .setDescription(`Modo de reproducci√≥n autom√°tica cambiado a \\`${autoPlayState ? \"ACTIVADO\" : \"DESACTIVADO\"}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [autoplayEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1766},"commands/messages/backward.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Backward\",\n    aliases: [\"BW\", \"Rewind\", \"atras\", \"rebobinar\"],\n    description: \"Retrocede la canci√≥n que se est√° reproduciendo.\",\n    usage: \"Backward <Segundos>\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const time = Number(args[0]);\n\n        if (!args[0] || isNaN(time)) {\n            const noArgsEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"¬°Por favor proporciona el tiempo (en segundos) para retroceder!\\n**Ejemplo:** `10` para retroceder 10 segundos.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [noArgsEmbed] });\n        }\n\n        try {\n            await queue.seek(queue.currentTime - time);\n\n            const seekEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è™ Retroceder\")\n                .setDescription(`He retrocedido la canci√≥n ${time} segundos.`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [seekEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2331},"commands/messages/connect.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Connect\",\n    aliases: [\"C\", \"J\", \"Join\", \"conectar\", \"unir\"],\n    description: \"Se conecta a tu canal de voz actual.\",\n    category: \"Comandos de Utilidades\",\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        if (memberVC && botVC && memberVC.id === botVC.id) {\n            const inVoiceEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Ya estoy conectado a tu canal de voz.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [inVoiceEmbed] });\n        }\n\n        try {\n            await client.distube.voices.join(memberVC);\n\n            const joinEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üëãüèª Conectar\")\n                .setDescription(\"Me he conectado a tu canal de voz.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [joinEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2190},"commands/messages/disconnect.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Disconnect\",\n    aliases: [\"DC\", \"L\", \"Left\", \"Leave\", \"desconectar\", \"salir\"],\n    description: \"Se desconecta de tu canal de voz.\",\n    category: \"Comandos de Utilidades\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        try {\n            await client.distube.voices.leave(message.guild);\n\n            const leaveEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üëãüèª Desconectar\")\n                .setDescription(\"Me he desconectado de tu canal de voz.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [leaveEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1631},"commands/messages/filters.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Filter\",\n    aliases: [\"F\", \"Mode\", \"Filters\", \"filtro\", \"filtros\"],\n    description: \"Aplica diferentes filtros de audio.\",\n    usage: \"Filter <Filtro>\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const filter = args[0]?.toLowerCase();\n\n        if (!args[0]) {\n            const noArgsEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\n                    \"Por favor ingresa un filtro v√°lido o `OFF`.\\n\\n**Filtros V√°lidos:** `3D` | `BassBoost` | `Earwax` | `Echo` | `Flanger` | `Gate` | `Haas` | `Karaoke` | `Mcompand` | `NightCore` |  `Phaser` | `Reverse` | `Surround` | `Tremolo` | `VaporWave`\"\n                );\n\n            return message.reply({ embeds: [noArgsEmbed] });\n        }\n\n        try {\n            if (filter === \"off\" && queue.filters.size) {\n                await queue.filters.clear();\n            } else if (Object.keys(client.distube.filters).includes(filter)) {\n                if (queue.filters.has(filter)) {\n                    await queue.filters.remove(filter);\n                } else {\n                    await queue.filters.add(filter);\n                }\n            } else if (args[0]) {\n                const notAvalidFilter = new Discord.EmbedBuilder()\n                    .setColor(config.WarnColor)\n                    .setTitle(\"‚ö†Ô∏è Advertencia\")\n                    .setDescription(\n                        \"Por favor ingresa un filtro v√°lido o `OFF`.\\n\\n**Filtros V√°lidos:** `3D` | `Bassboost` | `Echo` | `Karaoke` | `Nightcore` | `Vaporwave` | `Flanger` | `Gate` | `Haas` | `Reverse` | `Surround` | `Mcompand` | `Phaser` | `Tremolo` | `Earwax`\"\n                    )\n                    .setFooter({\n                        text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                        iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                    });\n\n                return message.reply({ embeds: [notAvalidFilter] });\n            }\n\n            const filtersEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üéß Filtro\")\n                .setDescription(`**Filtros Actuales de la Cola:** \\`${queue.filters.names.join(\", \") || \"OFF\"}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [filtersEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":3547},"commands/messages/forward.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Forward\",\n    aliases: [\"FW\", \"adelante\", \"avanzar\"],\n    description: \"Avanza la canci√≥n que se est√° reproduciendo.\",\n    usage: \"Forward <Segundos>\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const time = Number(args[0]);\n\n        if (!args[0] || isNaN(time)) {\n            const noArgsEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"¬°Por favor proporciona el tiempo (en segundos) para avanzar!\\n**Ejemplo:** `10` para avanzar 10 segundos!\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [noArgsEmbed] });\n        }\n\n        try {\n            await queue.seek(queue.currentTime + time);\n\n            const seekEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è© Avanzar\")\n                .setDescription(`He avanzado la canci√≥n ${time} segundos.`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [seekEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2305},"commands/messages/help.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Help\",\n    aliases: [\"H\", \"CMD\", \"CMDs\", \"Command\", \"Commands\", \"ayuda\", \"comandos\"],\n    description: \"Muestra la lista de comandos e informaci√≥n del bot.\",\n    usage: \"Help [COMANDO]\",\n    category: \"Comandos de Utilidades\",\n    memberVoice: false,\n    botVoice: false,\n    sameVoice: false,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const playCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Comandos de Reproducci√≥n\");\n        const songCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Comandos de Canci√≥n\");\n        const queueCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Comandos de Cola\");\n        const utilitiesCommands = [...client.MessageCommands.values()].filter((command) => command.category === \"Comandos de Utilidades\");\n\n        const helpEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setTitle(\"‚ùì Ayuda\")\n            .setFooter({ text: \"Desarrollado por <@1404572152014962708> ‚Ä¢ Bot de M√∫sica Avanzado\" });\n\n        if (\n            args[0] &&\n            (client.MessageCommands.find((command) => command.name.toLowerCase() === args[0].toLowerCase()) ||\n                client.MessageCommands.find((c) => c.aliases?.map((aliase) => aliase.toLowerCase()).includes(args[0].toLowerCase())))\n        ) {\n            const command =\n                client.MessageCommands.find((command) => command.name.toLowerCase() === args[0].toLowerCase()) ||\n                client.MessageCommands.find((c) => c.aliases?.map((aliase) => aliase.toLowerCase()).includes(args[0].toLowerCase()));\n\n            helpEmbed.setDescription(`Informaci√≥n detallada sobre **${command.name}**:`).addFields(\n                {\n                    name: \"Nombre del Comando:\",\n                    value: `\\`${config.Prefix}${command.name}\\``,\n                    inline: false,\n                },\n                {\n                    name: \"Sin√≥nimos:\",\n                    value: command.aliases\n                        ? command.aliases.map((aliase) => `\\`${config.Prefix}${aliase}\\``).join(\" | \")\n                        : \"No hay sin√≥nimos para este comando\",\n                    inline: false,\n                },\n                {\n                    name: \"Uso:\",\n                    value: command.usage ? config.Prefix + command.usage : \"`No hay uso espec√≠fico para este comando`\",\n                    inline: false,\n                },\n                {\n                    name: \"Descripci√≥n:\",\n                    value: command.description || \"`No hay descripci√≥n para este comando`\",\n                    inline: false,\n                }\n            );\n        } else {\n            helpEmbed\n                .setDescription(\n                    `Tambi√©n puedes usar el comando \\`${config.Prefix}Help CMD\\` para acceder a informaci√≥n detallada sobre los comandos disponibles y sus funcionalidades. Bot desarrollado por <@1404572152014962708>`\n                )\n                .addFields(\n                    {\n                        name: \"üéµ Comandos de Reproducci√≥n:\",\n                        value: playCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    },\n                    {\n                        name: \"üé∂ Comandos de Canci√≥n:\",\n                        value: songCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    },\n                    {\n                        name: \"üìã Comandos de Cola:\",\n                        value: queueCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    },\n                    {\n                        name: \"üîß Comandos de Utilidades:\",\n                        value: utilitiesCommands.map((command) => \"`\" + config.Prefix + command.name + \"`\").join(\", \"),\n                        inline: false,\n                    }\n                );\n        }\n\n        await message.reply({ embeds: [helpEmbed] });\n    },\n};\n","size_bytes":4385},"commands/messages/loop.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Loop\",\n    aliases: [\"Repeat\", \"repetir\", \"bucle\"],\n    description: \"Cambia el modo de bucle.\",\n    usage: \"Loop <OFF / Song / Queue>\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        if (!args[0] || ![\"off\", \"song\", \"queue\"].includes(args[0].toLowerCase())) {\n            const noArgsEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa un modo v√°lido.\\n\\n**Modos V√°lidos:** `OFF` | `SONG` | `QUEUE`\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [noArgsEmbed] });\n        }\n\n        try {\n            let mode = 0;\n            if (args[0].toLowerCase() === \"song\") mode = 1;\n            else if (args[0].toLowerCase === \"queue\") mode = 2;\n\n            mode = await queue.setRepeatMode(mode);\n            mode = mode ? (mode === 2 ? \"Toda la Cola\" : \"Esta Canci√≥n\") : \"OFF\";\n\n            const loopEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîÅ Bucle\")\n                .setDescription(`Modo de bucle cambiado a \\`${mode}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [loopEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2568},"commands/messages/nowplaying.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"NowPlaying\",\n    aliases: [\"NP\", \"Now\", \"Song\", \"Music\", \"Playing\", \"Current\", \"ahora\", \"actual\"],\n    description: \"Muestra la canci√≥n que se est√° reproduciendo actualmente.\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const voiceChannelMembers = botVC.members.filter((member) => !member.user.bot);\n\n        const nowEmbed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setTitle(\"üíø Reproduciendo Ahora\")\n            .setDescription(\n                `Reproduciendo ahora **[${queue.songs[0].name} (${queue.songs[0].formattedDuration})](${queue.songs[0].url})** para ${\n                    voiceChannelMembers.size\n                } ${voiceChannelMembers.size > 1 ? \"oyentes\" : \"oyente\"} en ${botVC}\\n\\n${func.queueStatus(queue)}`\n            )\n            .setThumbnail(queue.songs[0]?.thumbnail)\n            .setFooter({\n                text: `Canci√≥n solicitada por ${queue.songs[0].user.globalName || queue.songs[0].user.username}`,\n                iconURL: queue.songs[0].user.displayAvatarURL({ size: 1024 }),\n            });\n\n        if (queue.songs[0].views)\n            nowEmbed.addFields({\n                name: \"üëÄ Views:\",\n                value: `${func.numberWithCommas(queue.songs[0].views)}`,\n                inline: true,\n            });\n\n        if (queue.songs[0].likes)\n            nowEmbed.addFields({\n                name: \"üëçüèª Likes:\",\n                value: `${func.numberWithCommas(queue.songs[0].likes)}`,\n                inline: true,\n            });\n\n        if (queue.songs[0].dislikes)\n            nowEmbed.addFields({\n                name: \"üëéüèª Dislikes:\",\n                value: `${func.numberWithCommas(queue.songs[0].dislikes)}`,\n                inline: true,\n            });\n\n        await message.reply({ embeds: [nowEmbed] });\n    },\n};\n","size_bytes":2150},"commands/messages/pause.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Pause\",\n    aliases: [\"Hold\", \"pausar\", \"pausa\"],\n    description: \"Pausa la canci√≥n actual.\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        if (queue.paused) {\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"La cola ya est√° pausada.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [pauseEmbed] });\n        }\n\n        try {\n            await queue.pause();\n\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è∏Ô∏è Pausado\")\n                .setDescription(\"He pausado la canci√≥n para ti.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [pauseEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2086},"commands/messages/ping.js":{"content":"const Discord = require(\"discord.js\");\nconst os = require(\"node:os\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Ping\",\n    aliases: [\"L\", \"Latency\", \"latencia\"],\n    description: \"Muestra la latencia del bot.\",\n    category: \"Comandos de Utilidades\",\n    memberVoice: false,\n    botVoice: false,\n    sameVoice: false,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const embed = new Discord.EmbedBuilder()\n            .setColor(config.MainColor)\n            .setTitle(\"üèì Pong!\")\n            .addFields(\n                {\n                    name: `üì° Ping:`,\n                    value: `${client.ws.ping}ms`,\n                    inline: true,\n                },\n                {\n                    name: `üíæ Memoria:`,\n                    value: `${func.numberWithCommas(Math.round(process.memoryUsage().rss / 1024 / 1024))}/${func.numberWithCommas(\n                        Math.round(os.totalmem() / 1024 / 1024)\n                    )}MB`,\n                    inline: true,\n                },\n                {\n                    name: `‚è≥ Tiempo en l√≠nea:`,\n                    value: func.timestamp(client.readyTimestamp),\n                    inline: false,\n                }\n            )\n            .setFooter({\n                text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                iconURL: message.author.displayAvatarURL({ size: 1024 }),\n            });\n\n        await message.reply({ embeds: [embed] });\n    },\n};\n","size_bytes":1616},"commands/messages/play.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Play\",\n    aliases: [\"P\", \"start\", \"reproducir\", \"tocar\"],\n    description: \"Reproduce m√∫sica para ti.\",\n    usage: \"Play <Nombre de la canci√≥n / URL de la canci√≥n / URL de lista de reproducci√≥n>\",\n    category: \"Comandos de Reproducci√≥n\",\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const string = args.join(\" \");\n        if (!string) {\n            const stringEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa una URL de canci√≥n o consulta para buscar.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [stringEmbed] });\n        }\n\n        try {\n            await client.distube.play(memberVC, string, {\n                member: message.member,\n                textChannel: message.channel,\n                message,\n            });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1922},"commands/messages/playskip.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"PlaySkip\",\n    aliases: [\"PS\", \"tocar-saltar\", \"reproducir-saltar\"],\n    description: \"Reproduce la canci√≥n y salta la canci√≥n actual.\",\n    usage: \"PlaySkip <Nombre de Canci√≥n / URL de Canci√≥n / URL de Lista>\",\n    category: \"Comandos de Reproducci√≥n\",\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const string = args.join(\" \");\n        if (!string) {\n            const stringEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa una URL de canci√≥n o consulta para buscar.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [stringEmbed] });\n        }\n\n        try {\n            // await client.distube.play(memberVC, string, {\n            //     member: message.member,\n            //     textChannel: message.channel,\n            //     message,\n            //     skip: true,\n            // });\n\n            await client.distube.play(memberVC, string, {\n                member: message.member,\n                textChannel: message.channel,\n                message,\n                position: 1,\n            });\n            await queue.skip();\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2229},"commands/messages/playtop.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"PlayTop\",\n    aliases: [\"PT\", \"primero\", \"top\"],\n    description: \"Reproduce la canci√≥n antes que otras canciones en la cola.\",\n    usage: \"PlayTop <Nombre de Canci√≥n / URL de Canci√≥n / URL de Lista>\",\n    category: \"Comandos de Reproducci√≥n\",\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const string = args.join(\" \");\n        if (!string) {\n            const stringEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa una URL de canci√≥n o consulta para buscar.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [stringEmbed] });\n        }\n\n        try {\n            await client.distube.play(memberVC, string, {\n                member: message.member,\n                textChannel: message.channel,\n                message,\n                position: 1,\n            });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1954},"commands/messages/previous.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Previous\",\n    aliases: [\"B\", \"Back\", \"anterior\", \"atras\"],\n    description: \"Reproduce la canci√≥n anterior.\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        try {\n            await queue.previous();\n\n            const skippedEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîô Anterior\")\n                .setDescription(\"Saltando a la canci√≥n anterior.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [skippedEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1567},"commands/messages/queue.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Queue\",\n    aliases: [\"Q\", \"List\", \"Playlist\", \"cola\", \"lista\"],\n    description: \"Muestra la cola actual del servidor.\", \n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const queueSongs = queue.songs.map(\n            (song, i) => `${i === 0 ? \"**Reproduciendo:**\" : `${i}.`} ${song.name} (${song.formattedDuration}) - ${song.user}`\n        );\n        const n = queue.songs.length / 20;\n        const embeds = [];\n\n        for (let i = 0; n > i; i++) {\n            const queueEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(`üìÉ Cola de ${message.guild.name} [${i + 1}/${Math.ceil(n)}]`)\n                .setDescription(queueSongs.slice(i * 20, (i + 1) * 20).join(\"\\n\"))\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            embeds.push(queueEmbed);\n        }\n\n        const { paginationStartButton, paginationBackButton, paginationForwardButton, paginationEndButton } = require(\"../../utils/components\");\n        const startButton = Discord.ButtonBuilder.from(paginationStartButton);\n        const backButton = Discord.ButtonBuilder.from(paginationBackButton);\n        const forwardButton = Discord.ButtonBuilder.from(paginationForwardButton);\n        const endButton = Discord.ButtonBuilder.from(paginationEndButton);\n\n        let group = new Discord.ActionRowBuilder().addComponents([\n            startButton.setDisabled(true),\n            backButton.setDisabled(true),\n            forwardButton.setDisabled(true),\n            endButton.setDisabled(true),\n        ]);\n        if (embeds.length > 1)\n            group = new Discord.ActionRowBuilder().addComponents([\n                startButton.setDisabled(true),\n                backButton.setDisabled(true),\n                forwardButton.setDisabled(false),\n                endButton.setDisabled(false),\n            ]);\n\n        const reply = await message.reply({\n            embeds: [embeds[0]],\n            components: [group],\n        });\n\n        const collector = reply.createMessageComponentCollector({ time: 60000 });\n\n        let currentPage = 0;\n\n        collector.on(\"collect\", async (int) => {\n            if (int.member.id !== message.member.id)\n                await int.reply({\n                    content: `Este bot√≥n solo funciona para ${message.author.globalName || message.author.username}`,\n                    ephemeral: true,\n                });\n\n            if (int.customId === \"page-start\") {\n                currentPage = 0;\n                group = new Discord.ActionRowBuilder().addComponents([\n                    startButton.setDisabled(true),\n                    backButton.setDisabled(true),\n                    forwardButton.setDisabled(false),\n                    endButton.setDisabled(false),\n                ]);\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            } else if (int.customId === \"page-back\") {\n                --currentPage;\n                if (currentPage === 0) {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(true),\n                        backButton.setDisabled(true),\n                        forwardButton.setDisabled(false),\n                        endButton.setDisabled(false),\n                    ]);\n                } else {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(false),\n                        backButton.setDisabled(false),\n                        forwardButton.setDisabled(false),\n                        endButton.setDisabled(false),\n                    ]);\n                }\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            } else if (int.customId === \"page-forward\") {\n                currentPage++;\n                if (currentPage === embeds.length - 1) {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(false),\n                        backButton.setDisabled(false),\n                        forwardButton.setDisabled(true),\n                        endButton.setDisabled(true),\n                    ]);\n                } else {\n                    group = new Discord.ActionRowBuilder().addComponents([\n                        startButton.setDisabled(false),\n                        backButton.setDisabled(false),\n                        forwardButton.setDisabled(false),\n                        endButton.setDisabled(false),\n                    ]);\n                }\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            } else if (int.customId === \"page-end\") {\n                currentPage = embeds.length - 1;\n                group = new Discord.ActionRowBuilder().addComponents([\n                    startButton.setDisabled(false),\n                    backButton.setDisabled(false),\n                    forwardButton.setDisabled(true),\n                    endButton.setDisabled(true),\n                ]);\n                int.update({ embeds: [embeds[currentPage]], components: [group] });\n            }\n        });\n\n        collector.on(\"end\", async (collected, reason) => {\n            if ([\"messageDelete\", \"messageDeleteBulk\"].includes(reason)) return;\n            await reply.edit({\n                components: [\n                    new Discord.ActionRowBuilder().addComponents(\n                        startButton.setDisabled(true),\n                        backButton.setDisabled(true),\n                        forwardButton.setDisabled(true),\n                        endButton.setDisabled(true)\n                    ),\n                ],\n            });\n        });\n    },\n};\n","size_bytes":6186},"commands/messages/resume.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Resume\",\n    aliases: [\"R\", \"UnPause\", \"reanudar\", \"continuar\"],\n    description: \"Reanuda la canci√≥n actual.\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        if (!queue.paused) {\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"La cola no est√° pausada.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [pauseEmbed] });\n        }\n\n        try {\n            await queue.resume();\n\n            const pauseEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚ñ∂Ô∏è Reanudar\")\n                .setDescription(\"He reanudado la canci√≥n para ti.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [pauseEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2108},"commands/messages/search.js":{"content":"const Discord = require(\"discord.js\");\nconst { YouTubePlugin } = require(\"@distube/youtube\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Search\",\n    aliases: [\"S\", \"buscar\", \"encontrar\"],\n    description: \"Busca canciones para ti.\",\n    usage: \"Search <Nombre de la Canci√≥n>\",\n    category: \"Comandos de Reproducci√≥n\",\n    memberVoice: true,\n    botVoice: false,\n    sameVoice: true,\n    queueNeeded: false,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const string = args.join(\" \");\n        if (!string) {\n            const stringEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa el nombre de una canci√≥n o consulta para buscar.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [stringEmbed] });\n        }\n\n        try {\n            const ytPlugin = new YouTubePlugin();\n            const songsArray = await ytPlugin.search(string, { type: \"video\", limit: client.distubeSettings.searchSongs, safeSearch: true });\n\n            const searchEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîç Buscar\")\n                .setDescription(\n                    `¬°Por favor selecciona una de las canciones de abajo para disfrutar tu canci√≥n elegida!\\n\\n` +\n                        songsArray.map((song, index) => `[${index + 1}.](${song.url}) ${song.name} (${song.formattedDuration})`).join(\"\\n\")\n                )\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(\"songsMenu\")\n                .setPlaceholder(\"Selecciona una canci√≥n.\")\n                .setMaxValues(songsArray.length)\n                .addOptions(\n                    songsArray.map((song) => {\n                        return {\n                            label: song.name.length > 80 ? song.name.slice(0, 77) + \"...\" : song.name,\n                            value: song.id,\n                        };\n                    })\n                );\n\n            const row = new Discord.ActionRowBuilder().addComponents(menu);\n\n            const reply = await message.reply({ embeds: [searchEmbed], components: [row] });\n            const collector = reply.createMessageComponentCollector({ time: 60000 });\n\n            collector.on(\"collect\", async (int) => {\n                if (int.member.id !== message.author.id)\n                    await int.reply({\n                        content: `No puedes usar esto, solo funciona para ${message.author.globalName || message.author.username}`,\n                        ephemeral: true,\n                    });\n\n                await collector.stop(\"played\");\n                await int.deferUpdate();\n\n                for (const value of int.values) {\n                    const thisSong = songsArray.find((song) => song.id === value);\n\n                    await client.distube.play(memberVC, thisSong.url, {\n                        member: message.member,\n                        textChannel: message.channel,\n                        reply,\n                    });\n                }\n            });\n\n            collector.on(\"end\", async (collected, reason) => {\n                if ([\"messageDelete\", \"messageDeleteBulk\"].includes(reason)) return;\n                menu.setDisabled();\n                const disabledRow = new Discord.ActionRowBuilder().addComponents(menu);\n                await reply.edit({ components: [disabledRow] });\n            });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":4595},"commands/messages/seek.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\nconst func = require(\"../../utils/functions\");\n\nmodule.exports = {\n    name: \"Seek\",\n    aliases: [\"Go\", \"To\", \"GoTo\", \"buscar\", \"ir\"],\n    description: \"Va a una posici√≥n espec√≠fica de la canci√≥n.\",\n    usage: \"Seek <Segundos>\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const time = Number(args[0]);\n\n        if (!args[0] || isNaN(time)) {\n            const noArgsEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"¬°Por favor proporciona la posici√≥n (en segundos) para ir!\\n**Ejemplo:** `10` para ir al segundo 10 de la canci√≥n.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [noArgsEmbed] });\n        }\n\n        try {\n            await queue.seek(time);\n\n            const seekEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è≥ Ir a\")\n                .setDescription(`He ido al segundo ${func.suffix(time)} de la canci√≥n.`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [seekEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2353},"commands/messages/shuffle.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Shuffle\",\n    aliases: [\"SH\", \"mezclar\", \"aleatorio\"],\n    description: \"Mezcla las canciones de la cola aleatoriamente.\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        try {\n            await queue.shuffle();\n\n            const shuffleEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîÄ Mezclar\")\n                .setDescription(\"He mezclado las canciones de la cola\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [shuffleEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1580},"commands/messages/skip.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Skip\",\n    aliases: [\"Next\", \"N\", \"saltar\", \"siguiente\"],\n    description: \"Salta a la siguiente canci√≥n.\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        try {\n            await queue.skip();\n\n            const skippedEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"‚è≠Ô∏è Saltar\")\n                .setDescription(\"Saltando a la siguiente canci√≥n.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [skippedEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1561},"commands/messages/skipto.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"SkipTo\",\n    aliases: [\"ST\", \"Jump\", \"saltar\", \"saltar-a\"],\n    description: \"Salta a la canci√≥n especificada por n√∫mero en la cola.\",\n    usage: \"SkipTo <N√∫mero de Canci√≥n>\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        if (!args[0] || isNaN(Number(args[0]))) {\n            const noArgsEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa un n√∫mero v√°lido.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [noArgsEmbed] });\n        }\n\n        try {\n            await client.distube.jump(message.guild, Number(args[0])).then(async (song) => {\n                const skippedEmbed = new Discord.EmbedBuilder()\n                    .setColor(config.MainColor)\n                    .setTitle(\"‚è≠Ô∏è Saltar a\")\n                    .setDescription(`He saltado a la **${args[0]}. [${song.name} (${song.formattedDuration})](${song.url})**`)\n                    .setFooter({\n                        text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                        iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                    });\n\n                await message.reply({ embeds: [skippedEmbed] });\n            });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":2374},"commands/messages/stop.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"Stop\",\n    aliases: [\"OFF\", \"Exit\", \"Quit\", \"parar\", \"detener\"],\n    description: \"Detiene la cola de reproducci√≥n.\",\n    category: \"Comandos de Cola\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        try {\n            await queue.stop();\n            if (client.distubeSettings.leaveOnStop) await queue.voice.leave();\n\n            const stopEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üö´ Detenido\")\n                .setDescription(\"He detenido la reproducci√≥n.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [stopEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":1640},"commands/messages/volume.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = {\n    name: \"volume\",\n    aliases: [\"V\", \"Vol\", \"Set\", \"SetVolume\", \"volumen\"],\n    description: \"Establece el volumen del reproductor.\",\n    usage: \"Volume <Volumen>\",\n    category: \"Comandos de Canci√≥n\",\n    memberVoice: true,\n    botVoice: true,\n    sameVoice: true,\n    queueNeeded: true,\n\n    async execute(client, message, args, cmd, memberVC, botVC, queue) {\n        const volume = parseInt(args[0]);\n        if (isNaN(volume)) {\n            const notValidNumberEmbed = new Discord.EmbedBuilder()\n                .setColor(config.WarnColor)\n                .setTitle(\"‚ö†Ô∏è Advertencia\")\n                .setDescription(\"Por favor ingresa un n√∫mero v√°lido.\")\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            return message.reply({ embeds: [notValidNumberEmbed] });\n        }\n\n        try {\n            if (volume > 200 || volume < 0) {\n                const volumeEmbed = new Discord.EmbedBuilder()\n                    .setColor(config.WarnColor)\n                    .setTitle(\"‚ö†Ô∏è Advertencia\")\n                    .setFooter({\n                        text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                        iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                    });\n\n                if (volume > 200) volumeEmbed.setDescription(\"No puedes establecer el volumen por encima de `200`\");\n                if (volume < 0) volumeEmbed.setDescription(\"No puedes establecer el volumen por debajo de `0`\");\n\n                return message.reply({ embeds: [volumeEmbed] });\n            }\n\n            await queue.setVolume(volume);\n\n            const volumeEmbed = new Discord.EmbedBuilder()\n                .setColor(config.MainColor)\n                .setTitle(\"üîä Volumen\")\n                .setDescription(`Volumen cambiado a \\`${volume}\\`\\n\\n${func.queueStatus(queue)}`)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [volumeEmbed] });\n        } catch (error) {\n            const errorEmbed = new Discord.EmbedBuilder()\n                .setColor(config.ErrorColor)\n                .setTitle(\"‚ùå Error\")\n                .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                .setFooter({\n                    text: `Solicitado por ${message.author.globalName || message.author.username}`,\n                    iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                });\n\n            await message.reply({ embeds: [errorEmbed] });\n        }\n    },\n};\n","size_bytes":3071},"events/discord/interactionCreate.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\nconst { validateCommandExecution } = require(\"../../utils/server-validator\");\nconst func = require(\"../../utils/functions\");\n\nmodule.exports = async (client, interaction) => {\n    if (interaction.isChatInputCommand()) {\n        // Validar que el servidor est√© autorizado\n        if (!require(\"../../utils/server-validator\").isServerAllowed(interaction.guild.id)) {\n            return interaction.reply({ content: \"‚ùå Este bot solo funciona en servidores autorizados.\", ephemeral: true });\n        }\n\n        if (\n            !interaction.channel.permissionsFor(interaction.guild.members.me).has([\"ViewChannel\", \"SendMessages\", \"EmbedLinks\", \"ReadMessageHistory\"])\n        )\n            return;\n\n        const command = client.SlashCommands.get(interaction.commandName);\n        if (command) {\n            const memberVC = interaction.member.voice.channel || null;\n            const botVC = interaction.guild.members.me.voice.channel || null;\n            const queue = client.distube.getQueue(interaction.guild) || null;\n\n            if (command.memberVoice) {\n                if (!memberVC) return interaction.reply({ content: \"‚ö†Ô∏è You aren't connected to any Voice Channel.\", ephemeral: true });\n            }\n\n            if (command.botVoice) {\n                if (!botVC) return interaction.reply({ content: \"‚ö†Ô∏è I'm not connected to any Voice Chnanel.\", ephemeral: true });\n            }\n\n            if (command.sameVoice) {\n                if (memberVC && botVC && memberVC.id !== botVC.id)\n                    return interaction.reply({ content: \"‚ö†Ô∏è You aren't connected to my Voice Channel.\", ephemeral: true });\n            }\n\n            if (command.queueNeeded) {\n                if (!queue) return interaction.reply({ content: \"‚ö†Ô∏è I'm not playing anything right now.\", ephemeral: true });\n            }\n\n            try {\n                command.execute(client, interaction, memberVC, botVC, queue);\n            } catch (error) {\n                return interaction\n                    .reply({ content: error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message, ephemeral: true })\n                    .catch(() => null);\n            }\n        }\n    } else if (interaction.isButton() || interaction.isStringSelectMenu()) {\n        // Validar que el servidor est√© autorizado para interacciones\n        if (!require(\"../../utils/server-validator\").isServerAllowed(interaction.guild.id)) {\n            return interaction.reply({ content: \"‚ùå Este bot solo funciona en servidores autorizados.\", ephemeral: true });\n        }\n\n        if (\n            [\"filters\", \"loop\", \"previous\", \"pauseUnpause\", \"next\", \"shuffle\", \"vol-down\", \"backward\", \"stop\", \"forward\", \"vol-up\"].includes(\n                interaction.customId\n            )\n        ) {\n            const memberVC = interaction.member.voice.channel || null;\n            const botVC = interaction.guild.members.me.voice.channel || null;\n\n            if (!memberVC) return interaction.reply({ content: \"‚ö†Ô∏è You aren't connected to any Voice Channel.\", ephemeral: true });\n\n            if (!botVC) return interaction.reply({ content: \"‚ö†Ô∏è I'm not connected to any Voice Chnanel.\", ephemeral: true });\n\n            if (memberVC && botVC && memberVC.id !== botVC.id)\n                return interaction.reply({ content: \"‚ö†Ô∏è You aren't connected to my Voice Channel.\", ephemeral: true });\n\n            await interaction.deferReply();\n\n            try {\n                const queue = client.distube.getQueue(interaction.guild) || null;\n\n                if (interaction.customId === \"filters\") {\n                    if (queue.filters.has(interaction.values[0])) {\n                        await queue.filters.remove(interaction.values[0]);\n                    } else {\n                        await queue.filters.add(interaction.values[0]);\n                    }\n\n                    const filtersEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"üéß Filter\")\n                        .setDescription(`**Current Queue Filters:** \\`${queue.filters.names.join(\", \") || \"OFF\"}\\`\\n\\n${func.queueStatus(queue)}`)\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [filtersEmbed] });\n                } else if (interaction.customId === \"loop\") {\n                    const currentLoopState = queue.repeatMode;\n                    const nextLoopMode = [0, 1, 2][(currentLoopState + 1) % 3];\n                    let mode = await queue.setRepeatMode(nextLoopMode);\n                    mode = mode ? (mode === 2 ? \"All Queue\" : \"This Song\") : \"OFF\";\n\n                    const loopEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"üîÅ Loop\")\n                        .setDescription(`Loop mode changed to \\`${mode}\\`\\n\\n${func.queueStatus(queue)}`)\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [loopEmbed] });\n                } else if (interaction.customId === \"previous\") {\n                    await queue.previous();\n\n                    const skippedEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"üîô Previous\")\n                        .setDescription(\"Skipping to the previus song.\")\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [skippedEmbed] });\n\n                    await collector.stop();\n                } else if (interaction.customId === \"pauseUnpause\") {\n                    if (queue.paused) {\n                        await queue.resume();\n                    } else {\n                        await queue.pause();\n                    }\n\n                    const pauseUnpauseEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(queue.paused ? \"‚è∏Ô∏è Pause\" : \"‚ñ∂Ô∏è Resume\")\n                        .setDescription(`${queue.paused ? \"Paused\" : \"Resumed\"} the song for you.`)\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [pauseUnpauseEmbed] });\n                } else if (interaction.customId === \"next\") {\n                    await queue.skip();\n\n                    const skippedEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"‚è≠Ô∏è Skip\")\n                        .setDescription(\"Skipping to the next song.\")\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [skippedEmbed] });\n                } else if (interaction.customId === \"shuffle\") {\n                    await queue.shuffle();\n\n                    const shuffleEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"üîÄ Shuffle\")\n                        .setDescription(\"Shuffled songs in the queue\")\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [shuffleEmbed] });\n                } else if (interaction.customId.startsWith(\"vol\")) {\n                    const volumeUpDown = interaction.customId.split(\"-\")[1];\n\n                    if (volumeUpDown === \"up\") {\n                        if (queue.volume === 200) {\n                            const volumeEmbed = new Discord.EmbedBuilder()\n                                .setColor(config.WarnColor)\n                                .setTitle(\"‚ö†Ô∏è Warn\")\n                                .setDescription(\"You can't make volume more than `200`\")\n                                .setFooter({\n                                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                                });\n\n                            return interaction.editReply({ embeds: [volumeEmbed] });\n                        }\n                        await queue.setVolume(queue.volume + 10);\n                    } else if (volumeUpDown === \"down\") {\n                        if (queue.volume === 0) {\n                            const volumeEmbed = new Discord.EmbedBuilder()\n                                .setColor(config.WarnColor)\n                                .setTitle(\"‚ö†Ô∏è Warn\")\n                                .setDescription(\"You can't make volume less than `0`\")\n                                .setFooter({\n                                    text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                                    iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                                });\n\n                            return interaction.editReply({ embeds: [volumeEmbed] });\n                        }\n                        await queue.setVolume(queue.volume - 10);\n                    }\n\n                    const volumeEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"üîä Volume\")\n                        .setDescription(`Volume changed to \\`${queue.volume}\\`\\n\\n${func.queueStatus(queue)}`)\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [volumeEmbed] });\n                } else if (interaction.customId === \"backward\") {\n                    await queue.seek(queue.currentTime - 10);\n\n                    const seekEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"‚è™ Backward\")\n                        .setDescription(`Backwarded the song for 10 seconds.`)\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [seekEmbed] });\n                } else if (interaction.customId === \"stop\") {\n                    await queue.stop();\n                    if (client.distubeSettings.leaveOnStop) await queue.voice.leave();\n\n                    const stopEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"üö´ Stop\")\n                        .setDescription(\"Stopped playing.\")\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [stopEmbed] });\n                } else if (interaction.customId === \"forward\") {\n                    await queue.seek(queue.currentTime + 10);\n\n                    const seekEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.MainColor)\n                        .setTitle(\"‚è© Forward\")\n                        .setDescription(`forwarded the song for 10 seconds.`)\n                        .setFooter({\n                            text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                            iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    await interaction.editReply({ embeds: [seekEmbed] });\n                }\n            } catch (error) {\n                const errorEmbed = new Discord.EmbedBuilder()\n                    .setColor(config.ErrorColor)\n                    .setTitle(\"‚ùå Error\")\n                    .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                    .setFooter({\n                        text: `Requested by ${interaction.user.globalName || interaction.user.username}`,\n                        iconURL: interaction.user.displayAvatarURL({ size: 1024 }),\n                    });\n\n                return interaction.editReply({ embeds: [errorEmbed] });\n            }\n        }\n    }\n};\n","size_bytes":13959},"events/discord/messageCreate.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\nconst { validateCommandExecution } = require(\"../../utils/server-validator\");\n\nmodule.exports = async (client, message) => {\n    if (message.channel.type === Discord.ChannelType.DM || message.system || message.author.bot) return;\n\n    ////////////////Execute Commands////////////////\n\n    if (message.content.toLowerCase().startsWith(config.Prefix)) {\n        // Validar que el servidor est√© autorizado\n        if (!validateCommandExecution(message)) {\n            return;\n        }\n\n        if (!message.channel.permissionsFor(message.guild.members.me).has([\"ViewChannel\", \"SendMessages\", \"EmbedLinks\", \"ReadMessageHistory\"]))\n            return;\n\n        const args = message.content.slice(config.Prefix.length).split(/ +/);\n        const cmd = args.shift().toLowerCase();\n        const command =\n            client.MessageCommands.get(cmd) || client.MessageCommands.find((c) => c.aliases && c.aliases.map((a) => a.toLowerCase()).includes(cmd));\n        if (command) {\n            await message.channel.sendTyping();\n\n            const memberVC = message.member.voice.channel || null;\n            const botVC = message.guild.members.me.voice.channel || null;\n            const queue = client.distube.getQueue(message.guild) || null;\n\n            if (command.memberVoice) {\n                if (!memberVC) {\n                    const inVoiceEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.WarnColor)\n                        .setTitle(\"‚ö†Ô∏è Warn\")\n                        .setDescription(\"You aren't connected to any Voice Channel.\")\n                        .setFooter({\n                            text: `Requested by ${message.author.globalName || message.author.username}`,\n                            iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    return message.reply({ embeds: [inVoiceEmbed] });\n                }\n            }\n\n            if (command.botVoice) {\n                if (!botVC) {\n                    const inVoiceEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.WarnColor)\n                        .setTitle(\"‚ö†Ô∏è Warn\")\n                        .setDescription(\"I'm not connected to any Voice Chnanel.\")\n                        .setFooter({\n                            text: `Requested by ${message.author.globalName || message.author.username}`,\n                            iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    return message.reply({ embeds: [inVoiceEmbed] });\n                }\n            }\n\n            if (command.sameVoice) {\n                if (memberVC && botVC && memberVC.id !== botVC.id) {\n                    const inVoiceEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.WarnColor)\n                        .setTitle(\"‚ö†Ô∏è Warn\")\n                        .setDescription(\"You aren't connected to my Voice Channel.\")\n                        .setFooter({\n                            text: `Requested by ${message.author.globalName || message.author.username}`,\n                            iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    return message.reply({ embeds: [inVoiceEmbed] });\n                }\n            }\n\n            if (command.queueNeeded) {\n                if (!queue) {\n                    const noQueueEmbed = new Discord.EmbedBuilder()\n                        .setColor(config.WarnColor)\n                        .setTitle(\"‚ö†Ô∏è Warn\")\n                        .setDescription(\"I'm not playing anything right now.\")\n                        .setFooter({\n                            text: `Requested by ${message.author.globalName || message.author.username}`,\n                            iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                        });\n\n                    return message.reply({ embeds: [noQueueEmbed] });\n                }\n            }\n\n            try {\n                command.execute(client, message, args, cmd, memberVC, botVC, queue);\n            } catch (error) {\n                const errorEmbed = new Discord.EmbedBuilder()\n                    .setColor(config.ErrorColor)\n                    .setTitle(\"‚ùå Error\")\n                    .setDescription(error.message.length > 4096 ? error.message.slice(0, 4093) + \"...\" : error.message)\n                    .setFooter({\n                        text: `Requested by ${message.author.globalName || message.author.username}`,\n                        iconURL: message.author.displayAvatarURL({ size: 1024 }),\n                    });\n\n                return message.reply({ embeds: [errorEmbed] });\n            }\n        }\n    }\n};\n","size_bytes":4833},"events/discord/ready.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client) => {\n    await client.user.setPresence({\n        activities: [\n            {\n                name: `m√∫sica con ${config.Prefix}play`,\n                type: Discord.ActivityType.Listening,\n            },\n        ],\n        status: \"online\",\n    });\n\n    console.log(`${client.user.tag} est√° en l√≠nea y listo para reproducir m√∫sica para ti! Desarrollado por <@1404572152014962708>`);\n};\n","size_bytes":506},"events/discord/voiceStateUpdate.js":{"content":"const Discord = require(\"discord.js\");\nconst Distube = require(\"distube\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client, oldState, newState) => {\n    if (!oldState?.channel) return;\n    if (client.distubeSettings.leaveOnEmpty) {\n        const connection = client.distube.voices.get(oldState);\n        if (connection && Distube.isVoiceChannelEmpty(oldState)) {\n            const queue = client.distube.queues.get(oldState);\n            const textChannel = queue?.textChannel;\n\n            await connection.leave();\n\n            if (textChannel) {\n                const embed = new Discord.EmbedBuilder()\n                    .setColor(config.WarnColor)\n                    .setTitle(\"üëãüèª Leaving\")\n                    .setDescription(\"The voice channel is empty! Leaving the voice channel.\");\n\n                await textChannel?.send({ embeds: [embed] });\n            }\n        }\n    }\n};\n","size_bytes":924},"events/distube/addList.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client, queue, playlist) => {\n    const embed = new Discord.EmbedBuilder()\n        .setColor(config.MainColor)\n        .setTitle(\"üìÉ Nueva Cola\")\n        .setDescription(`Nueva lista de reproducci√≥n agregada a la cola\\n**Lista:** ${playlist.name} (${playlist.songs.length} canciones)\\n\\nüéµ Bot desarrollado por <@1404572152014962708>`)\n        .setFooter({\n            text: `Solicitado por ${playlist.songs[0].user.globalName || playlist.songs[0].user.username}`,\n            iconURL: playlist.songs[0].user.displayAvatarURL({ size: 1024 }),\n        });\n\n    await queue.textChannel?.send({ embeds: [embed] });\n};\n","size_bytes":729},"events/distube/addSong.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client, queue, song) => {\n    const embed = new Discord.EmbedBuilder()\n        .setColor(config.MainColor)\n        .setTitle(\"üé∂ Nueva Canci√≥n\")\n        .setDescription(`Nueva canci√≥n agregada a la cola\\n**Canci√≥n:** [${song.name} (${song.formattedDuration})](${song.url})\\n\\nüéµ Bot desarrollado por <@1404572152014962708>`)\n        .setFooter({\n            text: `Solicitado por ${song.user.globalName || song.user.username}`,\n            iconURL: song.user.displayAvatarURL({ size: 1024 }),\n        });\n\n    await queue.textChannel?.send({ embeds: [embed] });\n};\n","size_bytes":681},"events/distube/error.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client, error, queue, song) => {\n    const embed = new Discord.EmbedBuilder()\n    .setColor(config.ErrorColor)\n    .setTitle(\"‚ùå Error\")\n    .setDescription(`Ocurri√≥ un error: ${error}\\n\\nüîß Bot desarrollado por <@1404572152014962708>`);\n    await queue.textChannel?.send({ embeds: [embed] });\n    console.error(error)\n};\n","size_bytes":435},"events/distube/finish.js":{"content":"module.exports = async (client, queue) => {\n    if (client.distubeSettings.leaveOnFinish) {\n        setTimeout(async () => {\n            await queue.voice.leave();\n        }, client.distubeSettings.emptyCooldown * 1000);\n    }\n};\n","size_bytes":230},"events/distube/finishSong.js":{"content":"module.exports = async (client, queue) => {\n    const previousMessage = await queue.textChannel?.messages.fetch(client.PlayingMessageID).catch(() => null);\n\n    if (previousMessage) {\n        if (client.distubeSettings.deleteAfterFinish) {\n            await previousMessage.delete();\n        } else {\n            await previousMessage.edit({ components: [] });\n        }\n    }\n};\n","size_bytes":380},"events/distube/noRelated.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client, queue) => {\n    const embed = new Discord.EmbedBuilder()\n        .setColor(config.ErrorColor)\n        .setTitle(\"üö´ Sin Canciones Relacionadas\")\n        .setDescription(\"No puedo encontrar canciones relacionadas para reproducir\\n\\nüéµ Bot desarrollado por <@1404572152014962708>\");\n\n    await queue.textChannel?.send({ embeds: [embed] });\n};\n","size_bytes":462},"events/distube/playSong.js":{"content":"const Discord = require(\"discord.js\");\nconst func = require(\"../../utils/functions\");\nconst config = require(\"../../config.json\");\n\nmodule.exports = async (client, queue, song) => {\n    const voiceChannel = queue.distube.client.channels.cache.get(queue.voice.channelId);\n    const voiceChannelMembers = voiceChannel.members.filter((member) => !member.user.bot);\n\n    const embed = new Discord.EmbedBuilder()\n        .setColor(config.MainColor)\n        .setTitle(\"üíø Reproduciendo Ahora\")\n        .setDescription(\n            `Reproduciendo **[${song.name} (${song.formattedDuration})](${song.url})** para ${voiceChannelMembers.size} ${\n                voiceChannelMembers.size > 1 ? \"oyentes\" : \"oyente\"\n            } en ${voiceChannel}\\n\\nü§ñ Bot desarrollado por <@1404572152014962708>`\n        )\n        .setThumbnail(song?.thumbnail)\n        .setFooter({\n            text: `Canci√≥n solicitada por ${song.user.globalName || song.user.username}`,\n            iconURL: song.user.displayAvatarURL({ size: 1024 }),\n        });\n\n    if (song.views)\n        embed.addFields({\n            name: \"üëÄ Visualizaciones:\",\n            value: `${func.numberWithCommas(song.views)}`,\n            inline: true,\n        });\n\n    if (song.likes)\n        embed.addFields({\n            name: \"üëçüèª Me Gusta:\",\n            value: `${func.numberWithCommas(song.likes)}`,\n            inline: true,\n        });\n\n    if (song.dislikes)\n        embed.addFields({\n            name: \"üëéüèª No Me Gusta:\",\n            value: `${func.numberWithCommas(song.dislikes)}`,\n            inline: true,\n        });\n\n    const filters = new Discord.StringSelectMenuBuilder().setCustomId(\"filters\").setPlaceholder(\"Seleccionar Filtros\");\n\n    const options = [];\n\n    for (const filter of Object.keys(queue.distube.filters)) {\n        options.push({\n            label: filter.charAt(0).toUpperCase() + filter.slice(1),\n            value: filter,\n        });\n    }\n\n    filters.addOptions(options);\n    const row1 = new Discord.ActionRowBuilder().addComponents([filters]);\n\n    const loopSongToggle = new Discord.ButtonBuilder().setCustomId(\"loop\").setEmoji(\"üîÅ\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const previousSong = new Discord.ButtonBuilder().setCustomId(\"previous\").setEmoji(\"‚èÆÔ∏è\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const paunseUnpause = new Discord.ButtonBuilder().setCustomId(\"pauseUnpause\").setEmoji(\"‚èØÔ∏è\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const nextSong = new Discord.ButtonBuilder().setCustomId(\"next\").setEmoji(\"‚è≠Ô∏è\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const loopQueueToggle = new Discord.ButtonBuilder().setCustomId(\"shuffle\").setEmoji(\"üîÄ\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const volumeDown = new Discord.ButtonBuilder().setCustomId(\"vol-down\").setEmoji(\"üîâ\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const backward = new Discord.ButtonBuilder().setCustomId(\"backward\").setEmoji(\"‚è™\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const stop = new Discord.ButtonBuilder().setCustomId(\"stop\").setEmoji(\"‚èπÔ∏è\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const forward = new Discord.ButtonBuilder().setCustomId(\"forward\").setEmoji(\"‚è©\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const volumeUp = new Discord.ButtonBuilder().setCustomId(\"vol-up\").setEmoji(\"üîä\").setStyle(Discord.ButtonStyle.Secondary);\n\n    const row2 = new Discord.ActionRowBuilder().addComponents([loopSongToggle, previousSong, paunseUnpause, nextSong, loopQueueToggle]);\n    const row3 = new Discord.ActionRowBuilder().addComponents([volumeDown, backward, stop, forward, volumeUp]);\n\n    const playingMessage = await queue.textChannel?.send({\n        embeds: [embed],\n        components: [row1, row2, row3],\n    });\n\n    client.PlayingMessageID = playingMessage.id;\n};\n","size_bytes":3818},"docker-scripts/build.sh":{"content":"#!/bin/bash\n\necho \"üê≥ Construyendo Discord Music Bot Docker Image...\"\n\n# Construir la imagen\ndocker build -t discord-music-bot:latest .\n\nif [ $? -eq 0 ]; then\n    echo \"‚úÖ Imagen construida exitosamente!\"\n    echo \"\"\n    echo \"üìã Para ejecutar el contenedor:\"\n    echo \"   docker run -d --name discord-music-bot --env-file .env discord-music-bot:latest\"\n    echo \"\"\n    echo \"üìã O usar docker-compose:\"\n    echo \"   docker-compose up -d\"\nelse\n    echo \"‚ùå Error al construir la imagen\"\n    exit 1\nfi","size_bytes":507},"docker-scripts/run.sh":{"content":"#!/bin/bash\n\necho \"üöÄ Iniciando Discord Music Bot...\"\n\n# Verificar si existe el archivo .env\nif [ ! -f \".env\" ]; then\n    echo \"‚ö†Ô∏è  Archivo .env no encontrado. Creando desde .env.example...\"\n    if [ -f \".env.example\" ]; then\n        cp .env.example .env\n        echo \"üìù Por favor, edita el archivo .env con tus tokens de Discord antes de continuar.\"\n        exit 1\n    else\n        echo \"‚ùå No se encontr√≥ .env.example. Crea un archivo .env con tus configuraciones.\"\n        exit 1\n    fi\nfi\n\n# Usar docker-compose si existe\nif [ -f \"docker-compose.yml\" ]; then\n    echo \"üê≥ Usando docker-compose...\"\n    docker-compose up -d\n    \n    if [ $? -eq 0 ]; then\n        echo \"‚úÖ Bot iniciado exitosamente!\"\n        echo \"üìã Ver logs: docker-compose logs -f\"\n        echo \"üìã Parar bot: docker-compose down\"\n    else\n        echo \"‚ùå Error al iniciar el bot\"\n        exit 1\n    fi\nelse\n    # Ejecutar con docker run\n    echo \"üê≥ Usando docker run...\"\n    docker run -d \\\n        --name discord-music-bot \\\n        --env-file .env \\\n        --restart unless-stopped \\\n        -v $(pwd)/logs:/app/logs \\\n        discord-music-bot:latest\n    \n    if [ $? -eq 0 ]; then\n        echo \"‚úÖ Bot iniciado exitosamente!\"\n        echo \"üìã Ver logs: docker logs -f discord-music-bot\"\n        echo \"üìã Parar bot: docker stop discord-music-bot\"\n    else\n        echo \"‚ùå Error al iniciar el bot\"\n        exit 1\n    fi\nfi","size_bytes":1428},"docker-scripts/setup.sh":{"content":"#!/bin/bash\n\necho \"üõ†Ô∏è  Configuraci√≥n inicial de Discord Music Bot\"\n\n# Crear directorios necesarios\necho \"üìÅ Creando directorios...\"\nmkdir -p logs\nmkdir -p config\nmkdir -p docker-scripts\n\n# Hacer scripts ejecutables\nchmod +x docker-scripts/*.sh\n\n# Configurar .env\nif [ ! -f \".env\" ]; then\n    if [ -f \".env.example\" ]; then\n        cp .env.example .env\n        echo \"üìù Archivo .env creado desde .env.example\"\n    else\n        cat > .env << EOF\n# Discord Bot Configuration\nDISCORD_BOT_TOKEN=tu_bot_token_aqui\nDISCORD_CLIENT_ID=tu_client_id_aqui\n\n# Environment\nNODE_ENV=production\n\n# FFmpeg Path (se configura autom√°ticamente en Docker)\nFFMPEG_PATH=/usr/bin/ffmpeg\nEOF\n        echo \"üìù Archivo .env creado\"\n    fi\n    \n    echo \"\"\n    echo \"‚ö†Ô∏è  IMPORTANTE: Edita el archivo .env con tus tokens de Discord:\"\n    echo \"   - DISCORD_BOT_TOKEN: Token de tu bot desde Discord Developer Portal\"\n    echo \"   - DISCORD_CLIENT_ID: ID de cliente de tu aplicaci√≥n Discord\"\n    echo \"\"\nelse\n    echo \"‚úÖ Archivo .env ya existe\"\nfi\n\n# Informaci√≥n de siguiente paso\necho \"‚úÖ Configuraci√≥n inicial completada!\"\necho \"\"\necho \"üìã Pr√≥ximos pasos:\"\necho \"   1. Edita .env con tus tokens de Discord\"\necho \"   2. Ejecuta: ./docker-scripts/build.sh\"\necho \"   3. Ejecuta: ./docker-scripts/run.sh\"\necho \"\"\necho \"üìã Comandos √∫tiles:\"\necho \"   - Construir: ./docker-scripts/build.sh\"\necho \"   - Ejecutar: ./docker-scripts/run.sh\"\necho \"   - Ver logs: docker-compose logs -f\"\necho \"   - Parar: docker-compose down\"","size_bytes":1514},"utils/ffmpeg-resolver.js":{"content":"const { execSync } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Encuentra FFmpeg de manera robusta en cualquier sistema\n * Intenta m√∫ltiples m√©todos para garantizar compatibilidad\n */\nfunction findFfmpeg() {\n    // M√©todo 1: Intentar comando which/where (platform-specific)\n    try {\n        const command = process.platform === 'win32' ? 'where ffmpeg' : 'which ffmpeg';\n        const ffmpegPath = execSync(command, { \n            encoding: 'utf8', \n            timeout: 5000,\n            stdio: ['ignore', 'pipe', 'ignore']\n        }).trim();\n        if (ffmpegPath && fs.existsSync(ffmpegPath.split('\\n')[0])) {\n            console.log('‚úÖ FFmpeg encontrado via which/where:', ffmpegPath.split('\\n')[0]);\n            return ffmpegPath.split('\\n')[0];\n        }\n    } catch (error) {\n        console.log('‚ùå M√©todo which/where fall√≥');\n    }\n\n    // M√©todo 2: Intentar ffmpeg-static\n    try {\n        const ffmpegStatic = require('ffmpeg-static');\n        if (ffmpegStatic && fs.existsSync(ffmpegStatic)) {\n            console.log('‚úÖ FFmpeg encontrado via ffmpeg-static:', ffmpegStatic);\n            return ffmpegStatic;\n        }\n    } catch (error) {\n        console.log('‚ùå ffmpeg-static no disponible o sin binario');\n    }\n\n    // M√©todo 3: Rutas comunes del sistema\n    const commonPaths = [\n        '/usr/bin/ffmpeg',\n        '/usr/local/bin/ffmpeg',\n        '/opt/homebrew/bin/ffmpeg',\n        'C:\\\\ffmpeg\\\\bin\\\\ffmpeg.exe',\n        'C:\\\\Program Files\\\\ffmpeg\\\\bin\\\\ffmpeg.exe',\n    ];\n\n    for (const pathToTry of commonPaths) {\n        if (fs.existsSync(pathToTry)) {\n            console.log('‚úÖ FFmpeg encontrado en ruta com√∫n:', pathToTry);\n            return pathToTry;\n        }\n    }\n\n    // M√©todo 4: Buscar en PATH manualmente\n    const pathEnv = process.env.PATH || '';\n    const pathDirs = pathEnv.split(path.delimiter);\n    \n    for (const dir of pathDirs) {\n        const ffmpegPath = path.join(dir, process.platform === 'win32' ? 'ffmpeg.exe' : 'ffmpeg');\n        if (fs.existsSync(ffmpegPath)) {\n            console.log('‚úÖ FFmpeg encontrado en PATH:', ffmpegPath);\n            return ffmpegPath;\n        }\n    }\n\n    // M√©todo 5: Fallback - confiar en que est√° en PATH\n    console.log('‚ö†Ô∏è  Usando fallback: ffmpeg (debe estar en PATH)');\n    return 'ffmpeg';\n}\n\nmodule.exports = { findFfmpeg };","size_bytes":2389},"utils/server-validator.js":{"content":"/**\n * Valida que el bot solo funcione en servidores autorizados\n */\n\nconst ALLOWED_SERVERS = [\n    '1405727340335468665',\n    '1393290240214438021'\n];\n\n/**\n * Verifica si el servidor est√° autorizado\n * @param {string} guildId - ID del servidor\n * @returns {boolean} true si est√° autorizado\n */\nfunction isServerAllowed(guildId) {\n    return ALLOWED_SERVERS.includes(guildId);\n}\n\n/**\n * Valida y sale del servidor si no est√° autorizado\n * @param {import('discord.js').Guild} guild - Servidor de Discord\n */\nasync function validateAndLeaveIfUnauthorized(guild) {\n    if (!isServerAllowed(guild.id)) {\n        console.log(`‚ùå Servidor no autorizado detectado: ${guild.name} (${guild.id})`);\n        console.log(`üö™ Saliendo del servidor: ${guild.name}`);\n        \n        try {\n            // Intentar enviar mensaje antes de salir\n            const systemChannel = guild.systemChannel || guild.channels.cache.find(c => c.type === 0 && c.permissionsFor(guild.members.me).has('SendMessages'));\n            \n            if (systemChannel) {\n                await systemChannel.send('‚ùå Este bot solo funciona en servidores autorizados. Saliendo del servidor...');\n            }\n        } catch (error) {\n            console.log('No se pudo enviar mensaje de salida');\n        }\n        \n        // Salir del servidor despu√©s de 3 segundos\n        setTimeout(async () => {\n            try {\n                await guild.leave();\n                console.log(`‚úÖ Salida exitosa del servidor: ${guild.name}`);\n            } catch (error) {\n                console.error(`Error al salir del servidor ${guild.name}:`, error);\n            }\n        }, 3000);\n        \n        return false;\n    }\n    \n    console.log(`‚úÖ Servidor autorizado: ${guild.name} (${guild.id})`);\n    return true;\n}\n\n/**\n * Middleware para validar comandos solo en servidores autorizados\n * @param {import('discord.js').Message} message - Mensaje de Discord\n * @returns {boolean} true si el comando puede ejecutarse\n */\nfunction validateCommandExecution(message) {\n    if (!message.guild) {\n        // Comandos DM no permitidos\n        return false;\n    }\n    \n    if (!isServerAllowed(message.guild.id)) {\n        message.reply('‚ùå Este bot solo funciona en servidores autorizados.').catch(() => {});\n        return false;\n    }\n    \n    return true;\n}\n\nmodule.exports = {\n    isServerAllowed,\n    validateAndLeaveIfUnauthorized,\n    validateCommandExecution,\n    ALLOWED_SERVERS\n};","size_bytes":2458},"events/discord/clientReady.js":{"content":"const Discord = require(\"discord.js\");\nconst config = require(\"../../config.json\");\nconst { validateAndLeaveIfUnauthorized, ALLOWED_SERVERS } = require(\"../../utils/server-validator\");\n\nmodule.exports = async (client) => {\n    await client.user.setPresence({\n        activities: [\n            {\n                name: `m√∫sica con ${config.Prefix}play`,\n                type: Discord.ActivityType.Listening,\n            },\n        ],\n        status: \"online\",\n    });\n\n    console.log(`${client.user.tag} est√° en l√≠nea y listo para reproducir m√∫sica para ti! Desarrollado por <@1404572152014962708>`);\n    \n    // Validar servidores existentes\n    console.log(`üîç Validando ${client.guilds.cache.size} servidores...`);\n    console.log(`‚úÖ Servidores autorizados: ${ALLOWED_SERVERS.join(', ')}`);\n    \n    for (const guild of client.guilds.cache.values()) {\n        await validateAndLeaveIfUnauthorized(guild);\n    }\n    \n    console.log(`üõ°Ô∏è Validaci√≥n de servidores completada`);\n};\n","size_bytes":994},"events/discord/guildCreate.js":{"content":"const { validateAndLeaveIfUnauthorized } = require(\"../../utils/server-validator\");\n\nmodule.exports = async (client, guild) => {\n    console.log(`üì• Bot agregado a nuevo servidor: ${guild.name} (${guild.id})`);\n    \n    // Validar si el servidor est√° autorizado\n    const isAuthorized = await validateAndLeaveIfUnauthorized(guild);\n    \n    if (!isAuthorized) {\n        return; // El bot saldr√° autom√°ticamente del servidor\n    }\n    \n    console.log(`‚úÖ Bot autorizado y funcionando en: ${guild.name}`);\n};","size_bytes":513}},"version":1}